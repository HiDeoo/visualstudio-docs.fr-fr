---
title: 'CA2007 : N’attendez pas directement une Tâche'
ms.date: 03/08/2019
ms.topic: reference
f1_keywords:
- CA2007
- DoNotDirectlyAwaitATaskAnalyzer
helpviewer_keywords:
- CA2007
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
ms.openlocfilehash: 905e2f4143f36225c89a433a57ac83fad8f789f9
ms.sourcegitcommit: de98ed7edc81383e47b87ae6e61143fbbbe7bc56
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "88709569"
---
# <a name="ca2007-do-not-directly-await-a-task"></a>CA2007 : N’attendez pas directement une Tâche

|Élément|Valeur|
|-|-|
|CheckId|Ca2007|
|Category|Microsoft. fiabilité|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une méthode asynchrone [attend](/dotnet/csharp/language-reference/keywords/await) directement un <xref:System.Threading.Tasks.Task> .

## <a name="rule-description"></a>Description de la règle

Lorsqu’une méthode asynchrone attend directement une <xref:System.Threading.Tasks.Task> , la continuation se produit généralement dans le thread qui a créé la tâche, en fonction du contexte Async. Ce comportement peut être coûteux en termes de performances et peut entraîner un blocage sur le thread d’interface utilisateur. Envisagez <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> d’appeler pour signaler votre intention de continuation.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger les violations, appelez <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> sur le attendu <xref:System.Threading.Tasks.Task> . Vous pouvez passer soit `true` ou `false` pour le `continueOnCapturedContext` paramètre.

- `ConfigureAwait(true)`L’appel de sur la tâche a le même comportement que l’appel de manière explicite <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> . En appelant explicitement cette méthode, vous permettez aux lecteurs de savoir que vous souhaitez intentionnellement effectuer la continuation sur le contexte de synchronisation d’origine.

- Appelez `ConfigureAwait(false)` sur la tâche pour planifier les continuations vers le pool de threads, évitant ainsi un blocage sur le thread d’interface utilisateur. `false`Le passage à est une bonne option pour les bibliothèques indépendantes des applications.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Cet avertissement est destiné aux bibliothèques, où le code peut être exécuté dans des environnements arbitraires et où le code ne doit pas faire d’hypothèses sur l’environnement ou comment l’appelant de la méthode peut l’appeler ou l’attendre. Il est généralement préférable de supprimer entièrement l’avertissement pour les projets qui représentent le code de l’application plutôt que le code de bibliothèque. en fait, l’exécution de cet analyseur sur le code de l’application (par exemple, les gestionnaires d’événements de clic de bouton dans un projet WinForms ou WPF) risque d’entraîner des actions incorrectes.

Vous pouvez supprimer cet avertissement dans toutes les situations où la continuation doit être replanifiée dans le contexte d’origine ou lorsqu’il n’existe aucun contexte de ce type. Par exemple, lors de l’écriture de code dans un gestionnaire d’événements de clic sur un bouton dans une application WinForms ou WPF, en général, la continuation d’une instruction await doit s’exécuter sur le thread d’interface utilisateur. par conséquent, le comportement par défaut de la planification de la continuation vers le contexte d’origine est souhaitable. Autre exemple, lors de l’écriture de code dans une application ASP.NET Core, par défaut, il n’y a pas <xref:System.Threading.SynchronizationContext> <xref:System.Threading.Tasks.TaskScheduler> de ou, pour la raison pour laquelle un `ConfigureAwait` ne changerait pas de comportement.

## <a name="example"></a>Exemple

L’extrait de code suivant génère l’avertissement :

```csharp
public async Task Execute()
{
    Task task = null;
    await task;
}
```

Pour corriger la violation, appelez <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> sur le attendu <xref:System.Threading.Tasks.Task> :

```csharp
public async Task Execute()
{
    Task task = null;
    await task.ConfigureAwait(false);
}
```

## <a name="configurability"></a>Configurabilité

Vous pouvez configurer si vous souhaitez exclure des méthodes asynchrones qui ne retournent pas de valeur à partir de cette règle. Pour exclure ces genres de méthodes, ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
# Package version 2.9.0 and later
dotnet_code_quality.CA2007.exclude_async_void_methods = true

# Package version 2.6.3 and earlier
dotnet_code_quality.CA2007.skip_async_void_methods = true
```

Vous pouvez également configurer les types d’assembly de sortie auxquels appliquer cette règle. Par exemple, pour appliquer cette règle uniquement au code qui produit une application console ou une bibliothèque liée de manière dynamique (autrement dit, pas une application d’interface utilisateur), ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA2007.output_kind = ConsoleApplication, DynamicallyLinkedLibrary
```

Pour plus d’informations, consultez [configurer des analyseurs de qualité du code .net](configure-fxcop-analyzers.md).

## <a name="see-also"></a>Voir aussi

- [FAQ ConfigureAwait](https://devblogs.microsoft.com/dotnet/configureawait-faq/)
- [Dois-je attendre une tâche avec ConfigureAwait (false) ?](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md#should-i-await-a-task-with-configureawaitfalse)
