---
title: C26474
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26474
helpviewer_keywords:
- C26474
ms.assetid: 1e23a8e6-97fa-47f5-a279-b52aa2efafa4
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 824144a862c2bf8e8374b26534d34cc7203a64ea
ms.sourcegitcommit: 2193323efc608118e0ce6f6b2ff532f158245d56
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/25/2019
ms.locfileid: "55034885"
---
# <a name="c26474-noimplicitcast"></a>C26474 NO_IMPLICIT_CAST
« Ne cast entre types pointeur lorsque la conversion peut être implicite. »

**C++ Core Guidelines**: Type.1 : Évitez des conversions

Dans certains cas, les conversions implicites entre les types de pointeur peuvent être effectuées sans risque et ne nécessitent pas l’utilisateur d’écrire l’expression de cast spécifiques. Cette règle recherche les instances d’une telle conversion inutile, ce qui peut être supprimé.

## <a name="remarks"></a>Notes
- L’ID de règle est quelque peu trompeur : il doit être interprété comme « cast implicite ne sert pas où il est acceptable ».
  - La règle s’applique aux pointeurs uniquement et vérifie les casts statiques et réinterpréter casts.
  - Les cas suivants sont des conversions de pointeur acceptable que vous ne devraient pas utiliser des expressions de cast explicite :
  - conversion en nullptr_t ;
  - conversion en void * ;
  - conversion de type dérivé à sa base.
    ## <a name="example"></a>Exemple
    les conversions superflues masque une erreur logique

```cpp
template<class T>
bool register_buffer(T buffer) {
    auto p = reinterpret_cast<void*>(buffer); // C26474, also 26490 NO_REINTERPRET_CAST
    return buffers_.insert(p).second;
}

void merge_bytes(std::uint8_t *left, std::uint8_t *right)
{
    if (left && register_buffer(*left)) { // Unintended dereference!
        // ...
        if (right && register_buffer(right)) {
            // ...
        }
    }
}
```

## <a name="example"></a>Exemple
les conversions superflues masque erreur logique - retravaillée

```cpp
// ...
template<class T>
bool register_buffer(T *buffer) {
    auto p = buffer;
    return buffers_.insert(p).second;
}
// ...
```
