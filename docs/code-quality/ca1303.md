---
title: 'CA1303 : Ne pas transmettre des littéraux en tant que paramètres localisés'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 33d82ac6400b4ca4cae37fd5a63600407b18b543
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/01/2020
ms.locfileid: "75570789"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303 : Ne pas transmettre des littéraux en tant que paramètres localisés

|||
|-|-|
|TypeName|DoNotPassLiteralsAsLocalizedParameters|
|CheckId|CA1303|
|Catégorie|Microsoft. Globalization|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une méthode passe un littéral de chaîne en tant que paramètre à un constructeur .NET ou une méthode et cette chaîne doit être localisable.

Cet avertissement est déclenché quand une chaîne littérale est passée en tant que valeur à un paramètre ou une propriété et qu’un ou plusieurs des cas suivants sont vrais :

- L’attribut <xref:System.ComponentModel.LocalizableAttribute> du paramètre ou de la propriété a la valeur true.

- Le nom du paramètre ou de la propriété contient « Text », « message » ou « Caption ».

- Le nom du paramètre de chaîne passé à une méthode Console. Write ou console. WriteLine est « value » ou « format ».

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

## <a name="rule-description"></a>Description de la règle

Les littéraux de chaîne incorporés dans le code source sont difficiles à localiser.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, remplacez le littéral de chaîne par une chaîne récupérée par le biais d’une instance de la classe <xref:System.Resources.ResourceManager>.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Il est possible de supprimer sans risque un avertissement de cette règle si la bibliothèque de code n’est pas localisée ou si la chaîne n’est pas exposée à l’utilisateur final ou à un développeur à l’aide de la bibliothèque de code.

Les utilisateurs peuvent éliminer le bruit sur les méthodes qui ne doivent pas être passées aux chaînes localisées en renommant le paramètre ou la propriété, ou en marquant ces éléments comme conditionnels.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir d' [analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), cette règle est configurable.

### <a name="excluded-type-names-with-derived-types"></a>Noms de types exclus avec des types dérivés

Vous pouvez configurer les types, y compris ses types dérivés, à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas s’exécuter sur une méthode dans des types nommés `MyType` et ses types dérivés, ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de type uniquement (comprend tous les types portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole, avec un préfixe `T:` facultatif.

Exemples :

| Valeur d’option | Récapitulatif |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Met en correspondance tous les types nommés’MyType’et tous ses types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Correspond à tous les types nommés’MyType1 'ou’MyType2 'et tous leurs types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Correspond au type spécifique’MyType’avec le nom qualifié complet donné et tous ses types dérivés
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Met en correspondance les types spécifiques’MyType1 'et’MyType2 'avec les noms qualifiés complets respectifs et tous leurs types dérivés

Vous pouvez configurer cette option uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (globalisation). Pour plus d’informations, consultez [configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Exemple

L’exemple suivant montre une méthode qui lève une exception lorsque l’un de ses deux arguments est hors limites. Pour le premier argument, une chaîne littérale, qui viole cette règle, est passée au constructeur d’exception. Pour le deuxième argument, une chaîne Récupérée à l’aide d’un <xref:System.Resources.ResourceManager>est correctement passée au constructeur.

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Voir aussi

- [Ressources dans les applications de bureau](/dotnet/framework/resources/index)
