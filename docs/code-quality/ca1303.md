---
title: 'CA1303 : Ne pas passer de littéraux en paramètres localisés'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 2552bdd9b898a5f37e3186f4d975a626cea04b03
ms.sourcegitcommit: a18c7e9b367c2f92f6e54c3eaef442775d457667
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90096369"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303 : Ne pas passer de littéraux en paramètres localisés

|Élément|Valeur|
|-|-|
|ID de la règle|CA1303|
|Category|Microsoft. Globalization|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une méthode passe un littéral de chaîne en tant que paramètre à un constructeur .NET ou une méthode et cette chaîne doit être localisable.

Cet avertissement est déclenché quand une chaîne littérale est passée en tant que valeur à un paramètre ou une propriété et qu’un ou plusieurs des cas suivants sont vrais :

- L' <xref:System.ComponentModel.LocalizableAttribute> attribut du paramètre ou de la propriété a la valeur true.

- Le nom du paramètre de chaîne passé à une méthode Console. Write ou console. WriteLine est « value » ou « format ».

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#excluded-type-names-with-derived-types).

À partir de la version 3.0.0 du package de l’analyseur, l’heuristique d’attribution de noms n’est plus utilisée par défaut, mais elle peut [être configurée](#use-naming-heuristic).

## <a name="rule-description"></a>Description de la règle

Les littéraux de chaîne incorporés dans le code source sont difficiles à localiser.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, remplacez le littéral de chaîne par une chaîne récupérée par le biais d’une instance de la <xref:System.Resources.ResourceManager> classe.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Il est possible de supprimer sans risque un avertissement de cette règle si la bibliothèque de code n’est pas localisée ou si la chaîne n’est pas exposée à l’utilisateur final ou à un développeur à l’aide de la bibliothèque de code.

Les utilisateurs peuvent éliminer le bruit sur les méthodes qui ne doivent pas être passées aux chaînes localisées en renommant le paramètre ou la propriété, ou en marquant ces éléments comme conditionnels.

## <a name="configurability"></a>Configurabilité

Cette règle comporte les options configurables suivantes.

### <a name="excluded-type-names-with-derived-types"></a>Noms de types exclus avec des types dérivés

Vous pouvez configurer les types, y compris ses types dérivés, à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas s’exécuter sur les méthodes dans les types nommés `MyType` et ses types dérivés, ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :

- Nom de type uniquement (comprend tous les types portant le nom, quel que soit le type ou l’espace de noms conteneur)
- Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole, avec un `T:` préfixe facultatif.

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Met en correspondance tous les types nommés’MyType’et tous ses types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Correspond à tous les types nommés’MyType1 'ou’MyType2 'et tous leurs types dérivés dans la compilation
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Correspond au type spécifique’MyType’avec le nom qualifié complet donné et tous ses types dérivés
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Met en correspondance les types spécifiques’MyType1 'et’MyType2 'avec les noms qualifiés complets respectifs et tous leurs types dérivés

Vous pouvez configurer cette option uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (globalisation). Pour plus d’informations, consultez [configurer des analyseurs de qualité du code .net](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Utiliser l’heuristique d’appellation

Vous pouvez configurer si les paramètres ou les propriétés dont le nom contient « Text », « message » ou « Caption » déclenchent cette règle.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a> Exemple

L’exemple suivant montre une méthode qui lève une exception lorsque l’un de ses deux arguments est hors limites. Pour le premier argument, une chaîne littérale, qui viole cette règle, est passée au constructeur d’exception. Pour le deuxième argument, une chaîne Récupérée à l’aide d’un est correctement passée au constructeur <xref:System.Resources.ResourceManager> .

[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Voir aussi

- [Ressources dans des applications de bureau](/dotnet/framework/resources/index)
- [Demande de modification de comportement de la communauté](https://github.com/dotnet/roslyn-analyzers/issues/2933)
