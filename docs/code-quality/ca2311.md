---
title: 'CA2311 : Ne désérialisez pas sans définir d’abord NetDataContractSerializer.Binder'
ms.date: 05/01/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
f1_keywords:
- CA2311
- DoNotDeserializeWithoutFirstSettingNetDataContractSerializerBinder
ms.openlocfilehash: 1dae1d5dcc6863a424d37ee71abc25d5606389f0
ms.sourcegitcommit: de98ed7edc81383e47b87ae6e61143fbbbe7bc56
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "88707502"
---
# <a name="ca2311-do-not-deserialize-without-first-setting-netdatacontractserializerbinder"></a>CA2311 : Ne désérialisez pas sans définir d’abord NetDataContractSerializer.Binder

|Élément|Valeur|
|-|-|
|CheckId|CA2311|
|Category|Microsoft.Security|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=nameWithType> méthode de désérialisation a été appelée ou référencée sans que la <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder> propriété soit définie.

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

> [!WARNING]
> La restriction des types avec un SerializationBinder ne peut pas empêcher toutes les attaques. Pour plus d’informations, consultez le [Guide de sécurité BinaryFormatter](/dotnet/standard/serialization/binaryformatter-security-guide).

## <a name="rule-description"></a>Description de la règle

[!INCLUDE[insecure-deserializers-description](includes/insecure-deserializers-description-md.md)]

Cette règle recherche des <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=nameWithType> appels ou des références de méthode de désérialisation, lorsque <xref:System.Runtime.Serialization.NetDataContractSerializer> n’a pas son <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder> défini. Si vous souhaitez interdire toute désérialisation avec, <xref:System.Runtime.Serialization.NetDataContractSerializer> quelle que soit la <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder> propriété, désactivez cette règle et [CA2312](ca2312.md), et activez la règle [CA2310](ca2310.md).

## <a name="how-to-fix-violations"></a>Comment corriger les violations

[!INCLUDE[fix-binaryformatter-serializationbinder](includes/fix-binaryformatter-serializationbinder.md)]

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

`NetDataContractSerializer` n’est pas sécurisé et ne peut pas être sécurisé.

## <a name="configurability"></a>Configurabilité

Cette règle comporte les options configurables suivantes.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType` , ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA2311.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
- Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
- Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
- `.ctor` pour les constructeurs et `.cctor` les constructeurs statiques

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA2311.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA2311.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA2311.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA2311.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (sécurité). Pour plus d’informations, consultez [configurer des analyseurs de qualité du code .net](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Exemples de pseudo-code

### <a name="violation"></a>Violation

```csharp
using System;
using System.IO;
using System.Runtime.Serialization;

[DataContract]
public class BookRecord
{
    [DataMember]
    public string Title { get; set; }

    [DataMember]
    public AisleLocation Location { get; set; }
}

[DataContract]
public class AisleLocation
{
    [DataMember]
    public char Aisle { get; set; }

    [DataMember]
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public BookRecord DeserializeBookRecord(byte[] bytes)
    {
        NetDataContractSerializer serializer = new NetDataContractSerializer();
        using (MemoryStream ms = new MemoryStream(bytes))
        {
            return (BookRecord) serializer.Deserialize(ms);    // CA2311 violation
        }
    }
}
```

```vb
Imports System
Imports System.IO
Imports System.Runtime.Serialization

<DataContract()>
Public Class BookRecord
    <DataMember()>
    Public Property Title As String

    <DataMember()>
    Public Property Location As AisleLocation
End Class

<DataContract()>
Public Class AisleLocation
    <DataMember()>
    Public Property Aisle As Char

    <DataMember()>
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Function DeserializeBookRecord(bytes As Byte()) As BookRecord
        Dim serializer As NetDataContractSerializer = New NetDataContractSerializer()
        Using ms As MemoryStream = New MemoryStream(bytes)
            Return CType(serializer.Deserialize(ms), BookRecord)    ' CA2311 violation
        End Using
    End Function
End Class
```

### <a name="solution"></a>Solution

```csharp
using System;
using System.IO;
using System.Runtime.Serialization;

public class BookRecordSerializationBinder : SerializationBinder
{
    public override Type BindToType(string assemblyName, string typeName)
    {
        // One way to discover expected types is through testing deserialization
        // of **valid** data and logging the types used.

        ////Console.WriteLine($"BindToType('{assemblyName}', '{typeName}')");

        if (typeName == "BookRecord" || typeName == "AisleLocation")
        {
            return null;
        }
        else
        {
            throw new ArgumentException("Unexpected type", nameof(typeName));
        }
    }
}

[DataContract]
public class BookRecord
{
    [DataMember]
    public string Title { get; set; }

    [DataMember]
    public AisleLocation Location { get; set; }
}

[DataContract]
public class AisleLocation
{
    [DataMember]
    public char Aisle { get; set; }

    [DataMember]
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public BookRecord DeserializeBookRecord(byte[] bytes)
    {
        NetDataContractSerializer serializer = new NetDataContractSerializer();
        serializer.Binder = new BookRecordSerializationBinder();
        using (MemoryStream ms = new MemoryStream(bytes))
        {
            return (BookRecord) serializer.Deserialize(ms);
        }
    }
}
```

```vb
Imports System
Imports System.IO
Imports System.Runtime.Serialization

Public Class BookRecordSerializationBinder
    Inherits SerializationBinder

    Public Overrides Function BindToType(assemblyName As String, typeName As String) As Type
        ' One way to discover expected types is through testing deserialization
        ' of **valid** data and logging the types used.

        'Console.WriteLine($"BindToType('{assemblyName}', '{typeName}')")

        If typeName = "BinaryFormatterVB.BookRecord" Or typeName = "BinaryFormatterVB.AisleLocation" Then
            Return Nothing
        Else
            Throw New ArgumentException("Unexpected type", NameOf(typeName))
        End If
    End Function
End Class

<DataContract()>
Public Class BookRecord
    <DataMember()>
    Public Property Title As String

    <DataMember()>
    Public Property Location As AisleLocation
End Class

<DataContract()>
Public Class AisleLocation
    <DataMember()>
    Public Property Aisle As Char

    <DataMember()>
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Function DeserializeBookRecord(bytes As Byte()) As BookRecord
        Dim serializer As NetDataContractSerializer = New NetDataContractSerializer()
        serializer.Binder = New BookRecordSerializationBinder()
        Using ms As MemoryStream = New MemoryStream(bytes)
            Return CType(serializer.Deserialize(ms), BookRecord)
        End Using
    End Function
End Class
```

## <a name="related-rules"></a>Règles associées

[CA2310 : N’utilisez pas le désérialiseur non sécurisé NetDataContractSerializer](ca2310.md)

[CA2312 : Vérifiez que NetDataContractSerializer.Binder est défini avant la désérialisation](ca2312.md)
