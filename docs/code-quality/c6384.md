---
title: C6384
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: f1def1878ddae9521b2fa1caa7297600b92b9e46
ms.sourcegitcommit: 5f6ad1cefbcd3d531ce587ad30e684684f4c4d44
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/22/2019
ms.locfileid: "72746225"
---
# <a name="c6384"></a>C6384
AVERTISSEMENT C6384 : Division d’un pointeur sizeof par une autre valeur

 Cet avertissement indique qu’un calcul de taille peut être incorrect. Pour calculer le nombre d’éléments dans un tableau, il faut parfois diviser la taille du tableau par la taille du premier élément ; Toutefois, lorsque le tableau est en fait un pointeur, le résultat est généralement différent de celui prévu.

 Si le pointeur est un paramètre de fonction et que la taille de la mémoire tampon n’a pas été passée, il n’est pas possible de calculer la mémoire tampon maximale disponible. Lorsque le pointeur est alloué localement, la taille utilisée dans l’allocation doit être utilisée.

## <a name="example"></a>Exemple
 Le code suivant génère cet avertissement :

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);
  }
}
```

 Pour corriger cet avertissement, transmettez la taille de la mémoire tampon comme indiqué dans le code suivant :

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, SIZE);
  }
}
```

 Pour corriger cet avertissement à l’aide de la fonction de chaîne sécurisée _tcsncpy_s, utilisez le code suivant :

```
void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
   _tcsncpy_s(dest, SIZE, src, SIZE);
  }
}
```

 Notez que l’utilisation des nouvelles et des suppressions présente de nombreux pièges en termes de fuites de mémoire et d’exceptions. Pour éviter l’ensemble de ces types de fuites et de problèmes d’exception, utilisez les mécanismes fournis par C++ la bibliothèque STL (Standard Template Library). Il s’agit notamment de [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)et [Vector](/cpp/standard-library/vector). Pour plus d’informations, consultez [pointeurs intelligents](/cpp/cpp/smart-pointers-modern-cpp) et [ C++ bibliothèque standard](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>Voir aussi

- [_mbsnbcpy_s, _mbsnbcpy_s_l](/cpp/c-runtime-library/reference/mbsnbcpy-s-mbsnbcpy-s-l)
- [sizeof, opérateur](/cpp/cpp/sizeof-operator)
