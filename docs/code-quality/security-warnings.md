---
title: Avertissements liés à la sécurité
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 52ddee2e876576508573fbadedcc407f81703e18
ms.sourcegitcommit: 9f6f63a2d76c6e579b4b67a96ec86faba99ad1df
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/03/2019
ms.locfileid: "71933131"
---
# <a name="security-warnings"></a>Avertissements liés à la sécurité

Les avertissements de sécurité prennent en charge des bibliothèques et des applications plus sûres. Ces avertissements contribuent à empêcher la présence de défauts de sécurité dans votre programme. Si vous désactivez chacun de ces avertissements, vous devez indiquer clairement le motif de l’opération dans le code et également en informer le responsable de la sécurité désigné pour votre projet de développement.

## <a name="in-this-section"></a>Dans cette section

|Règle|Description|
|----------|-----------------|
|[CA2100 Examiner les requêtes SQL pour les vulnérabilités de sécurité](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md)|Une méthode définit la propriété System.Data.IDbCommand.CommandText à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode. Cette règle suppose que l’argument de chaîne contient des entrées d’utilisateur. Une chaîne de commande SQL construite à partir d’entrées d’utilisateur est vulnérable aux attaques d’injection SQL.|
|[CA2102 Intercepter les exceptions non CLSCompliant dans les gestionnaires généraux](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md)|Un membre dans un assembly qui n’est pas marqué avec RuntimeCompatibilityAttribute ou qui est marqué avec RuntimeCompatibility(WrapNonExceptionThrows = false) contient un bloc catch qui gère System.Exception et ne contient pas de bloc catch général immédiatement après.|
|[CA2103 Passer en revue la sécurité impérative](../code-quality/ca2103-review-imperative-security.md)|Une méthode utilise la sécurité impérative et est susceptible de construire l’autorisation à l’aide d’informations d’état ou de valeurs de retour qui peuvent changer pendant que la demande est active. Utilisez la sécurité de déclaration dès que possible.|
|[CA2104 Ne déclarez pas les types référence mutables en lecture seule](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md)|Un type visible de l’extérieur contient un champ en lecture seule visible de l’extérieur qui constitue un type référence mutable. Un type mutable est un type dont les données d’instance peuvent être modifiées.|
|[CA2105 Les champs de tableau ne doivent pas être en lecture seule](../code-quality/ca2105-array-fields-should-not-be-read-only.md)|Lorsque vous appliquez le modificateur en lecture seule (ReadOnly en Visual Basic) à un champ qui contient un tableau, ce champ ne peut pas être modifié pour référencer un tableau différent. Toutefois, les éléments du tableau stockés dans un champ en lecture seule peuvent être modifiés.|
|[CA2106 Assertions sécurisées](../code-quality/ca2106-secure-asserts.md)|Une méthode déclare une autorisation et aucune vérification de sécurité n’est exécutée sur l’appelant. L’assertion d’une autorisation de sécurité effectuée sans vérification de sécurité peut rendre votre code vulnérable et facile à exploiter.|
|[CA2107 Passer en revue l’utilisation de Deny et autoriser uniquement](../code-quality/ca2107-review-deny-and-permit-only-usage.md)|L’utilisation de la méthode PermitOnly et les actions de sécurité CodeAccessPermission. Deny doivent être utilisées uniquement par ceux qui ont une connaissance approfondie de la sécurité .NET. Le code qui utilise ces actions de sécurité doit subir une révision de sécurité.|
|[CA2108 Passer en revue la sécurité déclarative sur les types valeur](../code-quality/ca2108-review-declarative-security-on-value-types.md)|Un type valeur public ou protégé est sécurisé par l’accès aux données ou des demandes de liaison.|
|[CA2109 Passer en revue les gestionnaires d’événements visibles](../code-quality/ca2109-review-visible-event-handlers.md)|Une méthode de gestion d’événements publique ou protégée a été détectée. Les méthodes de gestion d'événements ne doivent pas être exposées sauf nécessité absolue.|
|[CA2111 Les pointeurs ne doivent pas être visibles](../code-quality/ca2111-pointers-should-not-be-visible.md)|Un pointeur n’est ni privé, ni interne ni en lecture seule. Un code malveillant peut modifier la valeur du pointeur, autorisant potentiellement l’accès aux emplacements arbitraires en mémoire ou provoquant des défaillances des applications ou du système.|
|[CA2112 Les types sécurisés ne doivent pas exposer de champs](../code-quality/ca2112-secured-types-should-not-expose-fields.md)|Un type public ou protégé contient des champs publics et est sécurisé par des demandes de liaison. Si un code a accès à une instance d’un type sécurisé par une demande de liaison, ce code n’a pas besoin de satisfaire la demande de liaison pour accéder aux champs du type.|
|[CA2114 La sécurité de la méthode doit être un sur-ensemble de type](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md)|Pour une même action, une méthode ne doit pas présenter de sécurité déclarative à la fois au niveau méthode et au niveau type.|
|[CA2115 Appelez GC. KeepAlive quand vous utilisez des ressources natives](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md)|Cette règle détecte les erreurs susceptibles de se produire du fait qu’une ressource non managée est en cours de finalisation alors qu’elle est encore utilisée dans un code non managé.|
|[CA2116 Les méthodes APTCA doivent uniquement appeler des méthodes APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale, et lorsque cet assembly exécute un code dans un autre assembly qui n’autorise pas les appelants dotés d’une confiance partielle, il devient possible d’exploiter une faille dans la sécurité.|
|[CA2117 Les types APTCA doivent uniquement étendre les types de base APTCA](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale et lorsqu’un type présent dans l’assembly hérite d’un type qui n’autorise pas les appelants partiellement approuvés, une exploitation de la sécurité devient possible.|
|[CA2118 Passer en revue l’utilisation de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md)|SuppressUnmanagedCodeSecurityAttribute modifie le comportement par défaut du système en matière de sécurité pour les membres qui exécutent le code non managé utilisant COM Interop ou l’appel de code non managé. Cet attribut est essentiellement utilisé pour accroître les performances ; toutefois, les gains de performance s’accompagnent de risques substantiels pour la sécurité.|
|[CA2119 Scellez les méthodes qui satisfont les interfaces privées](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md)|Un type public pouvant être hérité fournit une implémentation de méthode substituable d’une interface interne (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez la méthode d’être substituée en dehors de l’assembly.|
|[CA2120 Sécuriser les constructeurs de sérialisation](../code-quality/ca2120-secure-serialization-constructors.md)|Ce type possède un constructeur qui accepte un objet System.Runtime.Serialization.SerializationInfo et un objet System.Runtime.Serialization.StreamingContext (la signature du constructeur de sérialisation). Ce constructeur n’est pas sécurisé par une vérification de la sécurité, mais au moins un des constructeurs normaux dans le type est sécurisé.|
|[CA2121 Les constructeurs statiques doivent être privés](../code-quality/ca2121-static-constructors-should-be-private.md)|Le système appelle le constructeur statique avant la création de la première instance du type ou le référencement de tout membre statique. Si un constructeur statique n’est pas privé, il peut être appelé par un code autre que le système. Selon les opérations effectuées dans le constructeur, cette possibilité peut provoquer un comportement inattendu.|
|[CA2122 N’exposez pas indirectement des méthodes avec des demandes de liaison](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md)|Un membre public ou protégé a des demandes de liaison et est appelé par un membre qui ne procède à aucune vérification de la sécurité. Une demande de liaison vérifie uniquement les autorisations de l'appelant immédiat.|
|[CA2123 Les demandes de liaison de substitution doivent être identiques à la base](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md)|Cette règle met en correspondance une méthode et sa méthode de base, qui est soit une interface, soit une méthode virtuelle dans un autre type, puis compare les demandes de liaison sur chacune. Si cette règle est violée, un appelant malveillant peut ignorer la demande de liaison simplement en appelant la méthode non protégée.|
|[CA2124 Encapsuler les clauses finally vulnérables dans un bloc try externe](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md)|Une méthode publique ou protégée contient un bloc try/finally. Le bloc finally semble réinitialiser l’état de sécurité et n’est lui-même placé dans aucun bloc finally.|
|[CA2126 Les demandes de liaison de type requièrent des demandes d’héritage](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md)|Un type unsealed public est protégé par une demande de liaison et a une méthode substituable. Ni le type ni la méthode n’est protégé par une demande d’héritage.|
|[CA2130 Les constantes critiques de sécurité doivent être transparentes](../code-quality/ca2130-security-critical-constants-should-be-transparent.md)|La mise en application de la transparence n’est pas effectuée pour les valeurs de constante car les compilateurs alignent les valeurs de constante afin qu’aucune recherche ne soit requise au moment de l’exécution. Les champs constants doivent être transparents de sécurité (security-transparent) afin que les relecteurs de code ne supposent pas que le code transparent ne peut pas accéder à la constante.|
|[CA2131 Les types critiques de sécurité ne peuvent pas participer à l’équivalence de type](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md)|Un type participe à l’équivalence de type et le type lui-même, ou un membre ou champ du type, est marqué avec l’attribut SecurityCriticalAttribute. Cette règle se déclenche sur tout type ou type critique contenant des méthodes critiques ou des champs qui participent à l’équivalence de type. Lorsque le CLR détecte un tel type, il ne peut pas le charger avec une exception TypeLoadException au moment de l’exécution. En général, cette règle se déclenche uniquement lorsque les utilisateurs implémentent l’équivalence de type manuellement plutôt qu’en comptant sur tlbimp et les compilateurs pour faire l’équivalence de type.|
|[CA2132 Les constructeurs par défaut doivent être au moins aussi critiques que les constructeurs par défaut de type de base](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md)|Les types et les membres qui possèdent l’attribut SecurityCriticalAttribute ne peuvent pas être utilisés par le code d’application Silverlight. Les types et membres critiques de sécurité (security-critical) peuvent être uniquement utilisés par le code de confiance dans la bibliothèque de classes .NET Framework pour Silverlight. Dans la mesure où une construction publique ou protégée dans une classe dérivée doit avoir la même transparence ou une transparence supérieure à sa classe de base, une classe dans une application ne peut pas être dérivée d’une classe marquée SecurityCritical.|
|[CA2133 Les délégués doivent être liés aux méthodes avec une transparence cohérente](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md)|Cet avertissement se déclenche sur une méthode qui lie un délégué marqué à l’aide de SecurityCriticalAttribute à une méthode transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. L’avertissement déclenche également une méthode qui lie un délégué transparent ou critique sécurisé à une méthode critique.|
|[CA2134 Les méthodes doivent conserver une transparence cohérente lors de la substitution de méthodes de base](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md)|Cette règle se déclenche lorsqu’une méthode marquée à l’aide de SecurityCriticalAttribute substitue une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. Cette règle se déclenche également lorsqu’une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute substitue une méthode marquée à l’aide de SecurityCriticalAttribute. La règle est appliquée lors de la substitution d’une méthode virtuelle ou de l’implémentation d’une interface.|
|[CA2135 Les assemblys de niveau 2 ne doivent pas contenir de LinkDemands](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md)|L’utilisation de LinkDemands est déconseillée dans l’ensemble de règles de sécurité de niveau 2. Au lieu d’utiliser LinkDemands pour implémenter la sécurité au moment de la compilation juste-à-temps (JIT), marquez les méthodes, types et champs avec l’attribut SecurityCriticalAttribute.|
|[CA2136 Les membres ne doivent pas avoir d’annotations de transparence conflictuelles](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Les attributs de transparence sont appliqués à partir d’éléments de code de plus grande portée à des éléments de plus petite portée. Les attributs de transparence d’éléments de code avec une plus grande portée sont prioritaires sur les attributs de transparence des éléments de code contenus dans le premier élément. Par exemple, une classe marquée à l’aide de l’attribut SecurityCriticalAttribute ne peut pas contenir de méthode marquée à l’aide de l’attribut SecuritySafeCriticalAttribute.|
|[CA2137 Les méthodes transparentes doivent contenir uniquement le IL vérifiable](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md)|Une méthode contient du code non vérifiable ou retourne un type par référence. Cette règle se déclenche lorsque le code transparent de sécurité tente d’exécuter du code MSIL (Microsoft Intermediate Language) non vérifiable. Toutefois, la règle ne contient pas de vérificateur IL (Intermediate Language) complet, et à la place utilise l’heuristique pour intercepter la plupart des violations de vérification MSIL.|
|[CA2138 Les méthodes transparentes ne doivent pas appeler de méthodes avec l’attribut SuppressUnmanagedCodeSecurity](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md)|Une méthode transparente de sécurité appelle une méthode qui est marquée à l’aide de l’attribut SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139 Les méthodes transparentes ne peuvent pas utiliser l’attribut HandleProcessCorruptingExceptions](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md)|Cette règle se déclenche sur toute méthode transparente et tente de gérer une exception qui endommage un processus à l’aide de l’attribut HandleProcessCorruptedStateExceptionsAttribute. Une exception qui endommage un processus est une classification d’exception CLR version 4,0 d’exceptions comme <xref:System.AccessViolationException>. L’attribut HandleProcessCorruptedStateExceptionsAttribute peut uniquement être utilisé par des méthodes critiques de sécurité et sera ignoré s’il s’applique à une méthode transparente.|
|[CA2140 Le code transparent ne doit pas faire référence à des éléments critiques de sécurité](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Les méthodes marquées avec SecurityTransparentAttribute appellent des membres non publics marqués en tant que SecurityCritical. Cette règle analyse toutes les méthodes et tous les types d’un assembly qui sont transparents et critiques, et signale tous les appels du code transparent au code critique non public qui ne sont pas marqués SecurityTreatAsSafe.|
|[CA2141 : Les méthodes transparentes ne satisfont pas les LinkDemands](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md)|Une méthode transparente de sécurité appelle une méthode dans un assembly qui n’est pas marqué à l’aide de l’attribut APTCA (AllowPartiallyTrustedCallersAttribute), ou une méthode transparente de sécurité satisfait une demande LinkDemand pour un type ou une méthode.|
|[CA2142 Le code transparent ne doit pas être protégé avec LinkDemands](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md)|Cette règle se déclenche sur les méthodes transparentes qui requièrent l’accès de LinkDemands. Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations.|
|[CA2143 Les méthodes transparentes ne doivent pas utiliser de demandes de sécurité](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md)|Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations. Le code transparent de sécurité doit utiliser des demandes complètes pour prendre des décisions de sécurité et le code critique sécurisé ne doit pas dépendre du code transparent pour l’exécution de ces demandes.|
|[CA2144 Le code transparent ne doit pas charger d’assemblys à partir de tableaux d’octets](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md)|La révision de sécurité du code transparent n’est pas aussi complète que la révision de sécurité du code critique, car le code transparent ne peut pas exécuter d’actions relatives à la sécurité. Les assemblys chargés à partir d’un tableau d’octets peuvent ne pas être remarqués dans du code transparent, et ce tableau d’octets peut contenir du code critique, voire critique de sécurité, qui doit être audité.|
|[CA2145 Les méthodes transparentes ne doivent pas être décorées avec SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md)|Les méthodes décorées avec l’attribut SuppressUnmanagedCodeSecurityAttribute ont un LinkDemand implicite sur toute méthode qui l’appelle. Ce LinkDemand requiert que le code appelant soit critique de sécurité. Le marquage de la méthode qui utilise SuppressUnmanagedCodeSecurity avec l’attribut SecurityCriticalAttribute rend cette spécification plus évidente pour les appelants de la méthode.|
|[CA2146 Les types doivent être au moins aussi critiques que leurs types de base et interfaces](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md)|Cette règle se déclenche lorsqu’un type dérivé a un attribut de transparence de sécurité qui n’est pas aussi critique que son type de base ou l’interface implémentée. Seuls les types critiques peuvent dériver des types de base critiques ou implémenter des interfaces critiques, et seuls les types critiques ou critiques sécurisés peuvent dériver des types de base critiques sécurisés ou implémenter des interfaces critiques sécurisées.|
|[CA2147 Les méthodes transparentes ne peuvent pas utiliser d’assertions de sécurité](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est entièrement transparent ou mi-transparent et mi-critique, et elle signale toutes les utilisations déclaratives ou impératives d’Assert.|
|[CA2149 Les méthodes transparentes ne doivent pas appeler du code natif](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md)|Cette règle se déclenche sur toute méthode transparente qui appelle directement en code natif, par exemple, via un appel P/Invoke. Les violations de cette règle provoquent une exception MethodAccessException dans le modèle de transparence de niveau 2, et une demande complète pour le code UnmanagedCode dans le modèle de transparence de niveau 1.|
|[CA2151 Les champs avec des types critiques doivent être critiques pour la sécurité](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md)|Pour utiliser les types critiques de sécurité, le code qui référence le type doit être critique de sécurité ou critique sécurisé. Ceci est vrai même si la référence est indirecte. Par conséquent, un champ transparent de sécurité ou critique sécurisé est trompeur, car le code transparent ne pourra toujours pas accéder au champ.|
|[CA5122 : Les déclarations P-Invoke ne doivent pas être critiques sécurisées](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md)|Les méthodes sont marquées SecuritySafeCritical lorsqu’elles effectuent une opération relative à la sécurité, mais elle peuvent également être utilisées en toute sécurité par du code transparent. Le code transparent peut ne jamais appeler directement du code natif via P/Invoke. Par conséquent, marquer une méthode P/Invoke comme critique sécurisé ne permet pas au code transparent de l’appeler et s’avère trompeur pour l’analyse de sécurité.|
|@NO__T 0CA2153 : Évitez de gérer les exceptions d’état endommagé @ no__t-0|Les[exceptions d’état endommagé (CSE, Corrupted State Exceptions)](https://msdn.microsoft.com/magazine/dd419661.aspx) indiquent une altération de la mémoire dans votre processus. Le fait d’intercepter ces exceptions au lieu d’autoriser le processus à se bloquer peut engendrer des failles de sécurité si une personne malveillante réussit à placer une attaque dans la région de la mémoire endommagée.|
|@NO__T 0CA3075 : Traitement DTD non sécurisé @ no__t-0|Si vous utilisez des instances de DTDProcessing non sécurisées ou référencez des sources d’entités externes, l’analyseur peut accepter une entrée non fiable et divulguer des informations sensibles à des personnes malveillantes.|
|@NO__T 0CA3076 : Exécution du script XSLT non sécurisée @ no__t-0|Si vous exécutez le langage XSLT (Extensible Stylesheet Language Transformations) dans les applications .NET de manière non sécurisée, le processeur peut résoudre les références URI non fiables qui pourraient divulguer des informations sensibles à des personnes malveillantes, ce qui aboutirait à des attaques par déni de service et intersites.|
|@NO__T 0CA3077 : Traitement non sécurisé dans la conception d’API, le document XML et le lecteur de texte XML @ no__t-0|Lors de la conception d’une API dérivée de XMLDocument et XMLTextReader, tenez compte de DtdProcessing. L’utilisation d’instances de DTDProcessing non sécurisées lors de la référence ou la résolution de sources d’entités externes ou la définition de valeurs non sécurisées dans le code XML peut aboutir à la divulgation d’informations.|
|@NO__T 0CA3147 : Marquer des gestionnaires de verbe avec ValidateAntiForgeryToken @ no__t-0|Lors de la conception d’un contrôleur MVC ASP.NET, soyez attentif aux attaques de falsification de requête intersites. Une attaque de falsification de requête intersite peut envoyer des demandes malveillantes d’un utilisateur authentifié à votre contrôleur ASP.NET MVC.|
|@NO__T 0CA5361 : Ne désactivez pas l’utilisation de SChannel de chiffrement fort @ no__t-0|Le `Switch.System.Net.DontEnableSchUseStrongCrypto` paramètre `true` pour assouplit le chiffrement utilisé dans les connexions TLS (Transport Layer Security) sortantes. Un chiffrement plus faible peut compromettre la confidentialité de la communication entre votre application et le serveur, ce qui permet aux attaquants d’espionner facilement les données sensibles.|
|@NO__T 0CA5363 : Ne pas désactiver la validation de la demande @ no__t-0|La validation de la demande est une fonctionnalité de ASP.NET qui examine les requêtes HTTP et détermine si elles contiennent du contenu potentiellement dangereux pouvant entraîner des attaques par injection, y compris des scripts inter-sites.|
|[CA5364: Ne pas utiliser les protocoles de sécurité déconseillés](../code-quality/ca5364.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|@NO__T 0CA5369 : Utiliser XmlReader pour désérialiser @ no__t-0|Le traitement de schémas DTD et XML non fiables peut permettre le chargement de références externes dangereuses, qui doivent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|@NO__T 0CA5370 : Utiliser XmlReader pour valider le lecteur @ no__t-0|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. Ce chargement dangereux peut être restreint à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|@NO__T 0CA5371 : Utiliser XmlReader pour la lecture de schéma @ no__t-0|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. L’utilisation d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement de schéma Inline XML désactivé restreint les restrictions.|
|@NO__T 0CA5372 : Utiliser XmlReader pour XPathDocument @ no__t-0|Le traitement de code XML à partir de données non fiables peut charger des références externes dangereuses, qui peuvent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou lorsque le traitement DTD est désactivé.|
|@NO__T 0CA5373 : N’utilisez pas la fonction de dérivation de clé obsolète @ no__t-0|Cette règle détecte l’appel des méthodes <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> de dérivation de clé faible et. `Rfc2898DeriveBytes.CryptDeriveKey` <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>utilisé un algorithme PBKDF1 faible.|
|@NO__T 0CA5378 : Ne désactivez pas ServicePointManagerSecurityProtocols @ no__t-0|Le `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` paramètre `true` pour limite les connexions TLS (Transport Layer Security) de Windows Communication Framework (WCF) à l’utilisation de TLS 1,0. Cette version de TLS sera dépréciée.|
|@NO__T 0CA5380 : Ne pas ajouter de certificats au magasin racine @ no__t-0|Cette règle détecte le code qui ajoute un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui remplissent les conditions du programme de certification racine de Microsoft.|
|@NO__T 0CA5381 : Vérifier que les certificats ne sont pas ajoutés au magasin racine @ no__t-0|Cette règle détecte le code qui ajoute potentiellement un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui répondent aux exigences du programme de certification racine de Microsoft.|
|[CA5386: Éviter la valeur de codage SecurityProtocolType](../code-quality/ca5386.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour garantir la sécurité de votre application, évitez de coder en dur une version de protocole et ciblez au moins .NET Framework v 4.7.1.|
|@NO__T 0CA5389 : N’ajoutez pas le chemin d’accès de l’élément d’archive au chemin d’accès du système de fichiers cible @ no__t-0|Le chemin d’accès de fichier peut être relatif et peut entraîner l’accès au système de fichiers en dehors du chemin d’accès cible du système de fichiers attendu, ce qui conduit à des modifications de configuration malveillantes et à l’exécution de code à distance par le biais d’une technique de mise en attente.|
|[CA5397: Ne pas utiliser les valeurs SslProtocols déconseillées](../code-quality/ca5397.md)|ransport Layer Security (TLS) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|[CA5398: Éviter les valeurs SslProtocols codées en dur](../code-quality/ca5398.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour vous assurer que votre application reste sécurisée, évitez de coder en dur une version de protocole.|
