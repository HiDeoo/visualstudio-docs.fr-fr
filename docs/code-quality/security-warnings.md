---
title: Avertissements liés à la sécurité
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 004f10600df3ed2f9c1f62557e0915638482877e
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/01/2020
ms.locfileid: "75587210"
---
# <a name="security-warnings"></a>Avertissements liés à la sécurité

Les avertissements de sécurité prennent en charge des bibliothèques et des applications plus sûres. Ces avertissements contribuent à empêcher la présence de défauts de sécurité dans votre programme. Si vous désactivez chacun de ces avertissements, vous devez indiquer clairement le motif de l’opération dans le code et également en informer le responsable de la sécurité désigné pour votre projet de développement.

## <a name="in-this-section"></a>Dans cette section

|Règle|Description|
|----------|-----------------|
|[CA2100 : Recherchez les failles de sécurité dans des requêtes SQL](../code-quality/ca2100.md)|Une méthode définit la propriété System.Data.IDbCommand.CommandText à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode. Cette règle suppose que l’argument de chaîne contient des entrées d’utilisateur. Une chaîne de commande SQL construite à partir d’entrées d’utilisateur est vulnérable aux attaques d’injection SQL.|
|[CA2102 : Interceptez les exceptions non CLSCompliant dans des gestionnaires généraux](../code-quality/ca2102.md)|Un membre dans un assembly qui n’est pas marqué avec RuntimeCompatibilityAttribute ou qui est marqué avec RuntimeCompatibility(WrapNonExceptionThrows = false) contient un bloc catch qui gère System.Exception et ne contient pas de bloc catch général immédiatement après.|
|[CA2103 : Vérifiez la sécurité impérative](../code-quality/ca2103.md)|Une méthode utilise la sécurité impérative et est susceptible de construire l’autorisation à l’aide d’informations d’état ou de valeurs de retour qui peuvent changer pendant que la demande est active. Utilisez la sécurité de déclaration dès que possible.|
|[CA2104 : Ne déclarez pas les types référence mutables en lecture seule](../code-quality/ca2104.md)|Un type visible de l’extérieur contient un champ en lecture seule visible de l’extérieur qui constitue un type référence mutable. Un type mutable est un type dont les données d’instance peuvent être modifiées.|
|[CA2105 : Les champs de tableau ne doivent pas être en lecture seule](../code-quality/ca2105.md)|Lorsque vous appliquez le modificateur en lecture seule (ReadOnly en Visual Basic) à un champ qui contient un tableau, ce champ ne peut pas être modifié pour référencer un tableau différent. Toutefois, les éléments du tableau stockés dans un champ en lecture seule peuvent être modifiés.|
|[CA2106 : Sécurisez les assertions](../code-quality/ca2106.md)|Une méthode déclare une autorisation et aucune vérification de sécurité n’est exécutée sur l’appelant. L’assertion d’une autorisation de sécurité effectuée sans vérification de sécurité peut rendre votre code vulnérable et facile à exploiter.|
|[CA2107 : Passez en revue l’utilisation des méthodes Deny et PermitOnly](../code-quality/ca2107.md)|L’utilisation de la méthode PermitOnly et les actions de sécurité CodeAccessPermission. Deny doivent être utilisées uniquement par ceux qui ont une connaissance approfondie de la sécurité .NET. Le code qui utilise ces actions de sécurité doit subir une révision de sécurité.|
|[CA2108 : Vérifiez la sécurité déclarative dans les types de valeurs](../code-quality/ca2108.md)|Un type valeur public ou protégé est sécurisé par l’accès aux données ou des demandes de liaison.|
|[CA2109 : Passez en revue les gestionnaires d’événements visibles](../code-quality/ca2109.md)|Une méthode de gestion d’événements publique ou protégée a été détectée. Les méthodes de gestion d’événements ne doivent pas être exposées sauf nécessité absolue.|
|[CA2111 : Les pointeurs ne doivent pas être visibles](../code-quality/ca2111.md)|Un pointeur n’est ni privé, ni interne ni en lecture seule. Un code malveillant peut modifier la valeur du pointeur, autorisant potentiellement l’accès aux emplacements arbitraires en mémoire ou provoquant des défaillances des applications ou du système.|
|[CA2112 : Les types sécurisés ne doivent pas exposer de champs](../code-quality/ca2112.md)|Un type public ou protégé contient des champs publics et est sécurisé par des demandes de liaison. Si un code a accès à une instance d’un type sécurisé par une demande de liaison, ce code n’a pas besoin de satisfaire la demande de liaison pour accéder aux champs du type.|
|[CA2114 : La sécurité de la méthode doit être un sur-ensemble du type](../code-quality/ca2114.md)|Pour une même action, une méthode ne doit pas présenter de sécurité déclarative à la fois au niveau méthode et au niveau type.|
|[CA2115 : Appelez GC.KeepAlive lorsque vous utilisez des ressources natives](../code-quality/ca2115.md)|Cette règle détecte les erreurs susceptibles de se produire du fait qu’une ressource non managée est en cours de finalisation alors qu’elle est encore utilisée dans un code non managé.|
|[CA2116 : Les méthodes APTCA doivent appeler seulement des méthodes APTCA](../code-quality/ca2116.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale, et lorsque cet assembly exécute un code dans un autre assembly qui n’autorise pas les appelants dotés d’une confiance partielle, il devient possible d’exploiter une faille dans la sécurité.|
|[CA2117 : Les types APTCA doivent étendre seulement des types de base APTCA](../code-quality/ca2117.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale et lorsqu’un type présent dans l’assembly hérite d’un type qui n’autorise pas les appelants partiellement approuvés, une exploitation de la sécurité devient possible.|
|[CA2118 : Passez en revue l’utilisation de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute modifie le comportement par défaut du système en matière de sécurité pour les membres qui exécutent le code non managé utilisant COM Interop ou l’appel de code non managé. Cet attribut est essentiellement utilisé pour accroître les performances ; toutefois, les gains de performance s’accompagnent de risques substantiels pour la sécurité.|
|[CA2119 : Scellez les méthodes qui satisfont les interfaces privées](../code-quality/ca2119.md)|Un type public pouvant être hérité fournit une implémentation de méthode substituable d’une interface interne (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez la méthode d’être substituée en dehors de l’assembly.|
|[CA2120 : Sécurisez les constructeurs de sérialisation](../code-quality/ca2120.md)|Ce type possède un constructeur qui accepte un objet System.Runtime.Serialization.SerializationInfo et un objet System.Runtime.Serialization.StreamingContext (la signature du constructeur de sérialisation). Ce constructeur n’est pas sécurisé par une vérification de la sécurité, mais au moins un des constructeurs normaux dans le type est sécurisé.|
|[CA2121 : Les constructeurs statiques doivent être privés](../code-quality/ca2121.md)|Le système appelle le constructeur statique avant la création de la première instance du type ou le référencement de tout membre statique. Si un constructeur statique n’est pas privé, il peut être appelé par un code autre que le système. Selon les opérations effectuées dans le constructeur, cette possibilité peut provoquer un comportement inattendu.|
|[CA2122 : N’exposez pas indirectement des méthodes avec des demandes de liaison](../code-quality/ca2122.md)|Un membre public ou protégé a des demandes de liaison et est appelé par un membre qui ne procède à aucune vérification de la sécurité. Une demande de liaison vérifie uniquement les autorisations de l’appelant immédiat.|
|[CA2123 : Les demandes de liaison de substitution doivent être identiques au composant de base](../code-quality/ca2123.md)|Cette règle met en correspondance une méthode et sa méthode de base, qui est soit une interface, soit une méthode virtuelle dans un autre type, puis compare les demandes de liaison sur chacune. Si cette règle est violée, un appelant malveillant peut ignorer la demande de liaison simplement en appelant la méthode non protégée.|
|[CA2124 : Incluez dans un wrapper les clauses finally vulnérables dans un bloc try externe](../code-quality/ca2124.md)|Une méthode publique ou protégée contient un bloc try/finally. Le bloc finally semble réinitialiser l’état de sécurité et n’est lui-même placé dans aucun bloc finally.|
|[CA2126 : Les demandes de liaison de types nécessitent des demandes d’héritage](../code-quality/ca2126.md)|Un type unsealed public est protégé par une demande de liaison et a une méthode substituable. Ni le type ni la méthode n’est protégé par une demande d’héritage.|
|[CA2130 : Les constantes critiques de sécurité doivent être transparentes](../code-quality/ca2130.md)|La mise en application de la transparence n’est pas effectuée pour les valeurs de constante car les compilateurs alignent les valeurs de constante afin qu’aucune recherche ne soit requise au moment de l’exécution. Les champs constants doivent être transparents de sécurité (security-transparent) afin que les relecteurs de code ne supposent pas que le code transparent ne peut pas accéder à la constante.|
|[CA2131 : Les types critiques de sécurité ne peuvent pas participer à l’équivalence des types](../code-quality/ca2131.md)|Un type participe à l’équivalence de type et le type lui-même, ou un membre ou champ du type, est marqué avec l’attribut SecurityCriticalAttribute. Cette règle se déclenche sur tout type ou type critique contenant des méthodes critiques ou des champs qui participent à l’équivalence de type. Lorsque le CLR détecte un tel type, il ne peut pas le charger avec une exception TypeLoadException au moment de l’exécution. En général, cette règle se déclenche uniquement lorsque les utilisateurs implémentent l’équivalence de type manuellement plutôt qu’en comptant sur tlbimp et les compilateurs pour faire l’équivalence de type.|
|[CA2132 : Les constructeurs par défaut doivent être au moins aussi critiques que les constructeurs par défaut de type de base](../code-quality/ca2132.md)|Les types et les membres qui possèdent l’attribut SecurityCriticalAttribute ne peuvent pas être utilisés par le code d’application Silverlight. Les types et membres critiques de sécurité (security-critical) peuvent être uniquement utilisés par le code de confiance dans la bibliothèque de classes .NET Framework pour Silverlight. Dans la mesure où une construction publique ou protégée dans une classe dérivée doit avoir la même transparence ou une transparence supérieure à sa classe de base, une classe dans une application ne peut pas être dérivée d’une classe marquée SecurityCritical.|
|[CA2133 : Les délégués doivent lier les méthodes avec une transparence cohérente](../code-quality/ca2133.md)|Cet avertissement se déclenche sur une méthode qui lie un délégué marqué à l’aide de SecurityCriticalAttribute à une méthode transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. L’avertissement déclenche également une méthode qui lie un délégué transparent ou critique sécurisé à une méthode critique.|
|[CA2134 : La transparence des méthodes doit rester cohérente lors du remplacement des méthodes de base](../code-quality/ca2134.md)|Cette règle se déclenche lorsqu’une méthode marquée à l’aide de SecurityCriticalAttribute substitue une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. Cette règle se déclenche également lorsqu’une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute substitue une méthode marquée à l’aide de SecurityCriticalAttribute. La règle est appliquée lors de la substitution d’une méthode virtuelle ou de l’implémentation d’une interface.|
|[CA2135 : Les assemblys de niveau 2 ne doivent pas contenir de LinkDemands](../code-quality/ca2135.md)|L’utilisation de LinkDemands est déconseillée dans l’ensemble de règles de sécurité de niveau 2. Au lieu d’utiliser LinkDemands pour implémenter la sécurité au moment de la compilation juste-à-temps (JIT), marquez les méthodes, types et champs avec l’attribut SecurityCriticalAttribute.|
|[CA2136 : Les membres ne doivent pas avoir d’annotations de transparence en conflit](../code-quality/ca2136.md)|Les attributs de transparence sont appliqués à partir d’éléments de code de plus grande portée à des éléments de plus petite portée. Les attributs de transparence d’éléments de code avec une plus grande portée sont prioritaires sur les attributs de transparence des éléments de code contenus dans le premier élément. Par exemple, une classe marquée à l’aide de l’attribut SecurityCriticalAttribute ne peut pas contenir de méthode marquée à l’aide de l’attribut SecuritySafeCriticalAttribute.|
|[CA2137 : Les méthodes transparentes doivent contenir uniquement des IL vérifiables](../code-quality/ca2137.md)|Une méthode contient du code non vérifiable ou retourne un type par référence. Cette règle se déclenche lorsque le code transparent de sécurité tente d’exécuter du code MSIL (Microsoft Intermediate Language) non vérifiable. Toutefois, la règle ne contient pas de vérificateur IL (Intermediate Language) complet, et à la place utilise l’heuristique pour intercepter la plupart des violations de vérification MSIL.|
|[CA2138 : Les méthodes transparentes ne doivent pas appeler les méthodes avec l’attribut SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Une méthode transparente de sécurité appelle une méthode qui est marquée à l’aide de l’attribut SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139 : Les méthodes transparentes ne peuvent pas utiliser l’attribut HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Cette règle se déclenche sur toute méthode transparente et tente de gérer une exception qui endommage un processus à l’aide de l’attribut HandleProcessCorruptedStateExceptionsAttribute. Une exception qui endommage un processus est une classification d’exception CLR version 4,0 d’exceptions comme <xref:System.AccessViolationException>. L’attribut HandleProcessCorruptedStateExceptionsAttribute peut uniquement être utilisé par des méthodes critiques de sécurité et sera ignoré s’il s’applique à une méthode transparente.|
|[CA2140 : Le code transparent ne doit référencer des éléments critiques de sécurité](../code-quality/ca2140.md)|Les méthodes marquées avec SecurityTransparentAttribute appellent des membres non publics marqués en tant que SecurityCritical. Cette règle analyse toutes les méthodes et tous les types d’un assembly qui sont transparents et critiques, et signale tous les appels du code transparent au code critique non public qui ne sont pas marqués SecurityTreatAsSafe.|
|[CA2141 : Les méthodes transparentes ne satisfont pas les LinkDemands](../code-quality/ca2141.md)|Une méthode transparente de sécurité appelle une méthode dans un assembly qui n’est pas marqué à l’aide de l’attribut APTCA (AllowPartiallyTrustedCallersAttribute), ou une méthode transparente de sécurité satisfait une demande LinkDemand pour un type ou une méthode.|
|[CA2142 : Le code transparent ne doit pas être protégé avec des LinkDemands](../code-quality/ca2142.md)|Cette règle se déclenche sur les méthodes transparentes qui requièrent l’accès de LinkDemands. Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations.|
|[CA2143 : Les méthodes transparentes ne doivent pas utiliser de demandes de sécurité](../code-quality/ca2143.md)|Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations. Le code transparent de sécurité doit utiliser des demandes complètes pour prendre des décisions de sécurité et le code critique sécurisé ne doit pas dépendre du code transparent pour l’exécution de ces demandes.|
|[CA2144 : Le code transparent ne doit pas charger d’assemblys depuis des tableaux d’octets](../code-quality/ca2144.md)|La révision de sécurité du code transparent n’est pas aussi complète que la révision de sécurité du code critique, car le code transparent ne peut pas exécuter d’actions relatives à la sécurité. Les assemblys chargés à partir d’un tableau d’octets peuvent ne pas être remarqués dans du code transparent, et ce tableau d’octets peut contenir du code critique, voire critique de sécurité, qui doit être audité.|
|[CA2145 : Les méthodes transparentes ne doivent pas être décorées avec SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Les méthodes décorées avec l’attribut SuppressUnmanagedCodeSecurityAttribute ont un LinkDemand implicite sur toute méthode qui l’appelle. Ce LinkDemand requiert que le code appelant soit critique de sécurité. Le marquage de la méthode qui utilise SuppressUnmanagedCodeSecurity avec l’attribut SecurityCriticalAttribute rend cette spécification plus évidente pour les appelants de la méthode.|
|[CA2146 : Les types doivent être au moins aussi critiques que leurs types de base et leurs interfaces](../code-quality/ca2146.md)|Cette règle se déclenche lorsqu’un type dérivé a un attribut de transparence de sécurité qui n’est pas aussi critique que son type de base ou l’interface implémentée. Seuls les types critiques peuvent dériver des types de base critiques ou implémenter des interfaces critiques, et seuls les types critiques ou critiques sécurisés peuvent dériver des types de base critiques sécurisés ou implémenter des interfaces critiques sécurisées.|
|[CA2147 : Les méthodes transparentes ne peuvent pas utiliser d’assertions de sécurité](../code-quality/ca2147.md)|Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est entièrement transparent ou mi-transparent et mi-critique, et elle signale toutes les utilisations déclaratives ou impératives d’Assert.|
|[CA2149 : Les méthodes transparentes ne doivent pas appeler du code natif](../code-quality/ca2149.md)|Cette règle se déclenche sur toute méthode transparente qui appelle directement en code natif, par exemple, via un appel P/Invoke. Les violations de cette règle provoquent une exception MethodAccessException dans le modèle de transparence de niveau 2, et une demande complète pour le code UnmanagedCode dans le modèle de transparence de niveau 1.|
|[CA2151 : Les champs avec des types critiques doivent être des champs critiques de sécurité](../code-quality/ca2151.md)|Pour utiliser les types critiques de sécurité, le code qui référence le type doit être critique de sécurité ou critique sécurisé. Ceci est vrai même si la référence est indirecte. Par conséquent, un champ transparent de sécurité ou critique sécurisé est trompeur, car le code transparent ne pourra toujours pas accéder au champ.|
|[CA2153 : Évitez la gestion des exceptions d’état endommagé](../code-quality/ca2153.md)|Les[exceptions d’état endommagé (CSE, Corrupted State Exceptions)](https://msdn.microsoft.com/magazine/dd419661.aspx) indiquent une altération de la mémoire dans votre processus. Le fait d’intercepter ces exceptions au lieu d’autoriser le processus à se bloquer peut engendrer des failles de sécurité si une personne malveillante réussit à placer une attaque dans la région de la mémoire endommagée.|
|[Ca2300 : n’utilisez pas de désérialiseur non sécurisé BinaryFormatter](../code-quality/ca2300.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[Ca2301 : n’appelez pas BinaryFormatter. Deserialize sans définir au préalable BinaryFormatter. Binder](../code-quality/ca2301.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[Ca2302 : Vérifiez que BinaryFormatter. Binder est défini avant d’appeler BinaryFormatter. Deserialize](../code-quality/ca2302.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2305 : ne pas utiliser le désérialiseur non sécurisé LosFormatter](../code-quality/ca2305.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2310 : ne pas utiliser le désérialiseur non sécurisé NetDataContractSerializer](../code-quality/ca2310.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2311 : ne pas désérialiser sans définir au préalable NetDataContractSerializer. Binder](../code-quality/ca2311.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2312 : Vérifiez que NetDataContractSerializer. Binder est défini avant la désérialisation](../code-quality/ca2312.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2315 : ne pas utiliser le désérialiseur non sécurisé ObjectStateFormatter](../code-quality/ca2315.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2321 : ne pas désérialiser avec JavaScriptSerializer à l’aide d’un SimpleTypeResolver](../code-quality/ca2321.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2322 : Vérifiez que JavaScriptSerializer n’est pas initialisé avec SimpleTypeResolver avant la désérialisation](../code-quality/ca2322.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2326 : n’utilisez pas de valeurs TypeNameHandling autres que aucun](../code-quality/ca2326.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2327 : ne pas utiliser les JsonSerializerSettings non sécurisés](../code-quality/ca2327.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2328 : vérifier que les JsonSerializerSettings sont sécurisés](../code-quality/ca2328.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2329 : ne pas désérialiser avec JsonSerializer à l’aide d’une configuration non sécurisée](../code-quality/ca2329.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2330 : Vérifiez que JsonSerializer a une configuration sécurisée lors de la désérialisation.](../code-quality/ca2330.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA3001 : passez en revue le code pour les vulnérabilités d’injection SQL](../code-quality/ca3001.md)|Lorsque vous utilisez des commandes d’entrée et SQL non fiables, tenez-vous à l’esprit des attaques par injection SQL. Une attaque par injection de SQL peut exécuter des commandes SQL malveillantes et compromettre la sécurité et l’intégrité de votre application.|
|[Ca3002 : passez en revue le code pour les vulnérabilités XSS](../code-quality/ca3002.md)|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, gardez à l’esprit les attaques de script entre sites (XSS). Une attaque XSS injecte une entrée non fiable dans une sortie HTML brute, ce qui permet à la personne malveillante d’exécuter des scripts malveillants ou de modifier du contenu de manière malveillante dans votre page Web.|
|[Ca3003 : passez en revue le code pour les vulnérabilités d’injection de chemin de fichier](../code-quality/ca3003.md)|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, pensez à utiliser une entrée contrôlée par l’utilisateur lors de la spécification des chemins d’accès aux fichiers.|
|[Ca3004 : passez en revue le code pour les vulnérabilités de divulgation d’informations](../code-quality/ca3004.md)|La divulgation d’informations sur les exceptions permet aux attaquants d’obtenir des informations sur les éléments internes de votre application, ce qui peut aider les attaquants à trouver d’autres vulnérabilités à exploiter.|
|[Ca3006 : passez en revue le code pour traiter les vulnérabilités d’injection de commande](../code-quality/ca3006.md)|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de commande. Une attaque par injection de commande peut exécuter des commandes malveillantes sur le système d’exploitation sous-jacent, compromettant ainsi la sécurité et l’intégrité de votre serveur.|
|[CA3007 : passez en revue le code pour les vulnérabilités de redirection ouvertes](../code-quality/ca3007.md)|Lors de l’utilisation d’une entrée non fiable, tenez à l’esprit des vulnérabilités de redirection ouvertes. Une personne malveillante peut exploiter une vulnérabilité de redirection ouverte pour utiliser votre site Web afin de fournir l’apparence d’une URL légitime, mais de rediriger un visiteur non suspect vers une autre page Web malveillante ou malveillante.|
|[CA3008 : passez en revue le code pour les vulnérabilités d’injection XPath](../code-quality/ca3008.md)|Lors de l’utilisation d’une entrée non fiable, tenez-vous à l’esprit des attaques par injection XPath. La construction de requêtes XPath à l’aide d’une entrée non approuvée peut permettre à une personne malveillante de manipuler la requête de manière malveillante pour retourner un résultat inattendu et éventuellement divulguer le contenu du fichier XML interrogé.|
|[CA3009 : passez en revue le code pour les vulnérabilités d’injection XML](../code-quality/ca3009.md)|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection XML.|
|[Ca3010 : passez en revue le code pour les vulnérabilités d’injection XAML](../code-quality/ca3010.md)|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de code XAML. Le XAML est un langage de balisage qui représente directement l’instanciation d’objets et leur exécution. Cela signifie que les éléments créés en XAML peuvent interagir avec les ressources système (par exemple, l’accès réseau et l’e/s du système de fichiers).|
|[CA3011 : consultez le code pour les vulnérabilités d’injection de DLL](../code-quality/ca3011.md)|Lors de l’utilisation d’une entrée non fiable, pensez au chargement de code non fiable. Si votre application Web charge du code non fiable, une personne malveillante peut être en mesure d’injecter des dll malveillantes dans votre processus et d’exécuter du code malveillant.|
|[CA3012 : passez en revue le code pour les vulnérabilités d’injection Regex](../code-quality/ca3012.md)|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection de Regex. Une personne malveillante peut utiliser l’injection Regex pour modifier une expression régulière de manière malveillante, pour faire correspondre des résultats inattendus par l’expression régulière, ou pour faire en sorte que l’expression régulière consomme un processeur excessif, entraînant une attaque par déni de service.|
|[CA3061 : ne pas ajouter de schéma par URL](../code-quality/ca3061.md)|N’utilisez pas la surcharge unsafe de la méthode Add, car elle peut provoquer des références externes dangereuses.|
|[CA3075 : Traitement DTD non sécurisé](../code-quality/ca3075.md)|Si vous utilisez des instances de DTDProcessing non sécurisées ou référencez des sources d’entités externes, l’analyseur peut accepter une entrée non fiable et divulguer des informations sensibles à des personnes malveillantes.|
|[CA3076 : Exécution non sécurisée de script XSLT](../code-quality/ca3076.md)|Si vous exécutez le langage XSLT (Extensible Stylesheet Language Transformations) dans les applications .NET de manière non sécurisée, le processeur peut résoudre les références URI non fiables qui pourraient divulguer des informations sensibles à des personnes malveillantes, ce qui aboutirait à des attaques par déni de service et intersites.|
|[CA3077 : traitement non sécurisé dans la conception d’API, le document XML et le lecteur de texte XML](../code-quality/ca3077.md)|Lors de la conception d’une API dérivée de XMLDocument et XMLTextReader, tenez compte de DtdProcessing. L’utilisation d’instances de DTDProcessing non sécurisées lors de la référence ou la résolution de sources d’entités externes ou la définition de valeurs non sécurisées dans le code XML peut aboutir à la divulgation d’informations.|
|[CA3147 : marquer des gestionnaires de verbes avec ValidateAntiForgeryToken](../code-quality/ca3147.md)|Lors de la conception d’un contrôleur MVC ASP.NET, soyez attentif aux attaques de falsification de requête intersites. Une attaque de falsification de requête intersite peut envoyer des demandes malveillantes d’un utilisateur authentifié à votre contrôleur ASP.NET MVC.|
|[CA5122 : Les déclarations P-Invoke ne doivent pas être critiques sécurisées](../code-quality/ca5122.md)|Les méthodes sont marquées SecuritySafeCritical lorsqu’elles effectuent une opération relative à la sécurité, mais elle peuvent également être utilisées en toute sécurité par du code transparent. Le code transparent peut ne jamais appeler directement du code natif via P/Invoke. Par conséquent, marquer une méthode P/Invoke comme critique sécurisé ne permet pas au code transparent de l’appeler et s’avère trompeur pour l’analyse de sécurité.|
|[CA5361 : ne pas désactiver l’utilisation de SChannel de chiffrement fort](../code-quality/ca5361.md)|La définition de `Switch.System.Net.DontEnableSchUseStrongCrypto` sur `true` affaiblit le chiffrement utilisé dans les connexions TLS (Transport Layer Security) sortantes. Un chiffrement plus faible peut compromettre la confidentialité de la communication entre votre application et le serveur, ce qui permet aux attaquants d’espionner facilement les données sensibles.|
|[CA5363 : ne pas désactiver la validation de la demande](../code-quality/ca5363.md)|La validation de la demande est une fonctionnalité de ASP.NET qui examine les requêtes HTTP et détermine si elles contiennent du contenu potentiellement dangereux pouvant entraîner des attaques par injection, y compris des scripts inter-sites.|
|[CA5364 : ne pas utiliser les protocoles de sécurité déconseillés](../code-quality/ca5364.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|[CA5369 : utiliser XmlReader pour désérialiser](../code-quality/ca5369.md)|Le traitement de schémas DTD et XML non fiables peut permettre le chargement de références externes dangereuses, qui doivent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|[CA5370 : utiliser XmlReader pour valider le lecteur](../code-quality/ca5370.md)|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. Ce chargement dangereux peut être restreint à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|[CA5371 : utiliser XmlReader pour la lecture du schéma](../code-quality/ca5371.md)|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. L’utilisation d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement de schéma Inline XML désactivé restreint les restrictions.|
|[CA5372 : utiliser XmlReader pour XPathDocument](../code-quality/ca5372.md)|Le traitement de code XML à partir de données non fiables peut charger des références externes dangereuses, qui peuvent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou lorsque le traitement DTD est désactivé.|
|[CA5373 : ne pas utiliser la fonction de dérivation de clé obsolète](../code-quality/ca5373.md)|Cette règle détecte l’appel des méthodes de dérivation de clé faible <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> et `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> utilisé un algorithme PBKDF1 faible.|
|[CA5378 : ne pas désactiver ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|La définition de `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` sur `true` limite les connexions TLS (Transport Layer Security) de Windows Communication Framework (WCF) à l’utilisation de TLS 1,0. Cette version de TLS sera dépréciée.|
|[CA5380 : ne pas ajouter de certificats au magasin racine](../code-quality/ca5380.md)|Cette règle détecte le code qui ajoute un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui remplissent les conditions du programme de certification racine de Microsoft.|
|[CA5381 : vérifier que les certificats ne sont pas ajoutés au magasin racine](../code-quality/ca5381.md)|Cette règle détecte le code qui ajoute potentiellement un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui répondent aux exigences du programme de certification racine de Microsoft.|
|[CA5386 : éviter la valeur de codage SecurityProtocolType](../code-quality/ca5386.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour garantir la sécurité de votre application, évitez de coder en dur une version de protocole et ciblez au moins .NET Framework v 4.7.1.|
|[CA5389 : ne pas ajouter le chemin d’accès de l’élément d’archive au chemin d’accès du système de fichiers cible](../code-quality/ca5389.md)|Le chemin d’accès de fichier peut être relatif et peut entraîner l’accès au système de fichiers en dehors du chemin d’accès cible du système de fichiers attendu, ce qui conduit à des modifications de configuration malveillantes et à l’exécution de code à distance par le biais d’une technique de mise en attente.|
|[CA5397 : ne pas utiliser les valeurs SslProtocols déconseillées](../code-quality/ca5397.md)|ransport Layer Security (TLS) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|[CA5398 : éviter les valeurs SslProtocols codées en dur](../code-quality/ca5398.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour vous assurer que votre application reste sécurisée, évitez de coder en dur une version de protocole.|
