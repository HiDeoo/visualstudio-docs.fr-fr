---
title: Avertissements liés à la sécurité
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9b5a03c9cb7ae7c5a5c81bd452dbb04d8db4c09d
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/02/2020
ms.locfileid: "88052620"
---
# <a name="security-warnings"></a>Avertissements liés à la sécurité

Les avertissements de sécurité prennent en charge des bibliothèques et des applications plus sûres. Ces avertissements contribuent à empêcher la présence de défauts de sécurité dans votre programme. Si vous désactivez chacun de ces avertissements, vous devez indiquer clairement le motif de l’opération dans le code et également en informer le responsable de la sécurité désigné pour votre projet de développement.

## <a name="in-this-section"></a>Contenu de cette section

|Règle|Description|
|----------|-----------------|
|[CA2100 : Vérifier si les requêtes SQL présentent des failles de sécurité](../code-quality/ca2100.md)|Une méthode définit la propriété System.Data.IDbCommand.CommandText à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode. Cette règle suppose que l’argument de chaîne contient des entrées d’utilisateur. Une chaîne de commande SQL construite à partir d’entrées d’utilisateur est vulnérable aux attaques d’injection SQL.|
|[CA2102 : Interceptez les exceptions non CLSCompliant dans les gestionnaires généraux](../code-quality/ca2102.md)|Un membre dans un assembly qui n’est pas marqué avec RuntimeCompatibilityAttribute ou qui est marqué avec RuntimeCompatibility(WrapNonExceptionThrows = false) contient un bloc catch qui gère System.Exception et ne contient pas de bloc catch général immédiatement après.|
|[CA2103 : Vérifiez la sécurité impérative](../code-quality/ca2103.md)|Une méthode utilise la sécurité impérative et est susceptible de construire l’autorisation à l’aide d’informations d’état ou de valeurs de retour qui peuvent changer pendant que la demande est active. Utilisez la sécurité de déclaration dès que possible.|
|[CA2104 : Ne déclarez pas les types référence mutables en lecture seule](../code-quality/ca2104.md)|Un type visible de l’extérieur contient un champ en lecture seule visible de l’extérieur qui constitue un type référence mutable. Un type mutable est un type dont les données d’instance peuvent être modifiées.|
|[CA2105 : Les champs de tableau ne doivent pas être en lecture seule](../code-quality/ca2105.md)|Lorsque vous appliquez le modificateur en lecture seule (ReadOnly en Visual Basic) à un champ qui contient un tableau, ce champ ne peut pas être modifié pour référencer un tableau différent. Toutefois, les éléments du tableau stockés dans un champ en lecture seule peuvent être modifiés.|
|[CA2106 : Assertions sécurisées](../code-quality/ca2106.md)|Une méthode déclare une autorisation et aucune vérification de sécurité n’est exécutée sur l’appelant. L’assertion d’une autorisation de sécurité effectuée sans vérification de sécurité peut rendre votre code vulnérable et facile à exploiter.|
|[CA2107 : Passez en revue l'utilisation des méthodes Deny et PermitOnly](../code-quality/ca2107.md)|L’utilisation de la méthode PermitOnly et les actions de sécurité CodeAccessPermission. Deny doivent être utilisées uniquement par ceux qui ont une connaissance approfondie de la sécurité .NET. Le code qui utilise ces actions de sécurité doit subir une révision de sécurité.|
|[CA2108 : Vérifiez la sécurité déclarative dans les types valeur](../code-quality/ca2108.md)|Un type valeur public ou protégé est sécurisé par l’accès aux données ou des demandes de liaison.|
|[CA2109 : Passez en revue les gestionnaires d'événements visibles](../code-quality/ca2109.md)|Une méthode de gestion d’événements publique ou protégée a été détectée. Les méthodes de gestion d’événements ne doivent pas être exposées sauf nécessité absolue.|
|[CA2111 : Les pointeurs ne doivent pas être visibles](../code-quality/ca2111.md)|Un pointeur n’est ni privé, ni interne ni en lecture seule. Un code malveillant peut modifier la valeur du pointeur, autorisant potentiellement l’accès aux emplacements arbitraires en mémoire ou provoquant des défaillances des applications ou du système.|
|[CA2112 : Les types sécurisés ne doivent pas exposer de champs](../code-quality/ca2112.md)|Un type public ou protégé contient des champs publics et est sécurisé par des demandes de liaison. Si un code a accès à une instance d’un type sécurisé par une demande de liaison, ce code n’a pas besoin de satisfaire la demande de liaison pour accéder aux champs du type.|
|[CA2114 : La sécurité de la méthode doit être un sur-ensemble du type](../code-quality/ca2114.md)|Pour une même action, une méthode ne doit pas présenter de sécurité déclarative à la fois au niveau méthode et au niveau type.|
|[CA2115 : Appelez GC.KeepAlive lorsque vous utilisez des ressources natives](../code-quality/ca2115.md)|Cette règle détecte les erreurs susceptibles de se produire du fait qu’une ressource non managée est en cours de finalisation alors qu’elle est encore utilisée dans un code non managé.|
|[CA2116 : Les méthodes APTCA doivent uniquement appeler des méthodes APTCA](../code-quality/ca2116.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale, et lorsque cet assembly exécute un code dans un autre assembly qui n’autorise pas les appelants dotés d’une confiance partielle, il devient possible d’exploiter une faille dans la sécurité.|
|[CA2117 : Les types APTCA doivent uniquement étendre des types de base APTCA](../code-quality/ca2117.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale et lorsqu’un type présent dans l’assembly hérite d’un type qui n’autorise pas les appelants partiellement approuvés, une exploitation de la sécurité devient possible.|
|[CA2118 : Vérifier l'utilisation de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute modifie le comportement par défaut du système en matière de sécurité pour les membres qui exécutent le code non managé utilisant COM Interop ou l’appel de code non managé. Cet attribut est essentiellement utilisé pour accroître les performances ; toutefois, les gains de performance s’accompagnent de risques substantiels pour la sécurité.|
|[CA2119 : Scellez les méthodes qui satisfont les interfaces privées](../code-quality/ca2119.md)|Un type public pouvant être hérité fournit une implémentation de méthode substituable d’une interface interne (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez la méthode d’être substituée en dehors de l’assembly.|
|[CA2120 : Sécurisez les constructeurs de sérialisation](../code-quality/ca2120.md)|Ce type possède un constructeur qui accepte un objet System.Runtime.Serialization.SerializationInfo et un objet System.Runtime.Serialization.StreamingContext (la signature du constructeur de sérialisation). Ce constructeur n’est pas sécurisé par une vérification de la sécurité, mais au moins un des constructeurs normaux dans le type est sécurisé.|
|[CA2121 : Les constructeurs statiques doivent être privés](../code-quality/ca2121.md)|Le système appelle le constructeur statique avant la création de la première instance du type ou le référencement de tout membre statique. Si un constructeur statique n’est pas privé, il peut être appelé par un code autre que le système. Selon les opérations effectuées dans le constructeur, cette possibilité peut provoquer un comportement inattendu.|
|[CA2122 : N'exposez pas indirectement des méthodes avec des demandes de liaison](../code-quality/ca2122.md)|Un membre public ou protégé a des demandes de liaison et est appelé par un membre qui ne procède à aucune vérification de la sécurité. Une demande de liaison vérifie uniquement les autorisations de l’appelant immédiat.|
|[CA2123 : Les demandes de liaison de substitution doivent être identiques au composant de base](../code-quality/ca2123.md)|Cette règle met en correspondance une méthode et sa méthode de base, qui est soit une interface, soit une méthode virtuelle dans un autre type, puis compare les demandes de liaison sur chacune. Si cette règle est violée, un appelant malveillant peut ignorer la demande de liaison simplement en appelant la méthode non protégée.|
|[CA2124 : Incluez dans un wrapper les clauses finally vulnérables dans un bloc try externe](../code-quality/ca2124.md)|Une méthode publique ou protégée contient un bloc try/finally. Le bloc finally semble réinitialiser l’état de sécurité et n’est lui-même placé dans aucun bloc finally.|
|[CA2126 : Les demandes de liaison de type exigent des demandes d'héritage](../code-quality/ca2126.md)|Un type unsealed public est protégé par une demande de liaison et a une méthode substituable. Ni le type ni la méthode n’est protégé par une demande d’héritage.|
|[CA2130 : Les constantes critiques de sécurité doivent être transparentes](../code-quality/ca2130.md)|La mise en application de la transparence n’est pas effectuée pour les valeurs de constante car les compilateurs alignent les valeurs de constante afin qu’aucune recherche ne soit requise au moment de l’exécution. Les champs constants doivent être transparents de sécurité (security-transparent) afin que les relecteurs de code ne supposent pas que le code transparent ne peut pas accéder à la constante.|
|[CA2131 : Les types critiques de sécurité ne peuvent pas participer à l'équivalence des types](../code-quality/ca2131.md)|Un type participe à l’équivalence de type et le type lui-même, ou un membre ou champ du type, est marqué avec l’attribut SecurityCriticalAttribute. Cette règle se déclenche sur tout type ou type critique contenant des méthodes critiques ou des champs qui participent à l’équivalence de type. Lorsque le CLR détecte un tel type, il ne peut pas le charger avec une exception TypeLoadException au moment de l’exécution. En général, cette règle se déclenche uniquement lorsque les utilisateurs implémentent l’équivalence de type manuellement plutôt qu’en comptant sur tlbimp et les compilateurs pour faire l’équivalence de type.|
|[CA2132 : Les constructeurs par défaut doivent être au moins aussi critiques que les constructeurs par défaut de type de base](../code-quality/ca2132.md)|Les types et les membres qui possèdent l’attribut SecurityCriticalAttribute ne peuvent pas être utilisés par le code d’application Silverlight. Les types et membres critiques de sécurité (security-critical) peuvent être uniquement utilisés par le code de confiance dans la bibliothèque de classes .NET Framework pour Silverlight. Dans la mesure où une construction publique ou protégée dans une classe dérivée doit avoir la même transparence ou une transparence supérieure à sa classe de base, une classe dans une application ne peut pas être dérivée d’une classe marquée SecurityCritical.|
|[CA2133 : Les délégués doivent lier les méthodes avec une transparence cohérente](../code-quality/ca2133.md)|Cet avertissement se déclenche sur une méthode qui lie un délégué marqué à l’aide de SecurityCriticalAttribute à une méthode transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. L’avertissement déclenche également une méthode qui lie un délégué transparent ou critique sécurisé à une méthode critique.|
|[CA2134 : La transparence des méthodes doit rester cohérente lors de la substitution de méthodes de base](../code-quality/ca2134.md)|Cette règle se déclenche lorsqu’une méthode marquée à l’aide de SecurityCriticalAttribute substitue une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. Cette règle se déclenche également lorsqu’une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute substitue une méthode marquée à l’aide de SecurityCriticalAttribute. La règle est appliquée lors de la substitution d’une méthode virtuelle ou de l’implémentation d’une interface.|
|[CA2135 : Les assemblys de niveau 2 ne doivent pas contenir de LinkDemands](../code-quality/ca2135.md)|L’utilisation de LinkDemands est déconseillée dans l’ensemble de règles de sécurité de niveau 2. Au lieu d’utiliser LinkDemands pour implémenter la sécurité au moment de la compilation juste-à-temps (JIT), marquez les méthodes, types et champs avec l’attribut SecurityCriticalAttribute.|
|[CA2136 : Les membres ne doivent pas avoir d'annotations de transparence conflictuelles](../code-quality/ca2136.md)|Les attributs de transparence sont appliqués à partir d’éléments de code de plus grande portée à des éléments de plus petite portée. Les attributs de transparence d’éléments de code avec une plus grande portée sont prioritaires sur les attributs de transparence des éléments de code contenus dans le premier élément. Par exemple, une classe marquée à l’aide de l’attribut SecurityCriticalAttribute ne peut pas contenir de méthode marquée à l’aide de l’attribut SecuritySafeCriticalAttribute.|
|[CA2137 : Les méthodes transparentes doivent contenir uniquement des IL vérifiables](../code-quality/ca2137.md)|Une méthode contient du code non vérifiable ou retourne un type par référence. Cette règle se déclenche lorsque le code transparent de sécurité tente d’exécuter du code MSIL (Microsoft Intermediate Language) non vérifiable. Toutefois, la règle ne contient pas de vérificateur IL (Intermediate Language) complet, et à la place utilise l’heuristique pour intercepter la plupart des violations de vérification MSIL.|
|[CA2138 : Les méthodes transparentes ne doivent pas appeler les méthodes ayant l'attribut SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Une méthode transparente de sécurité appelle une méthode qui est marquée à l’aide de l’attribut SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139 : Les méthodes transparentes ne peuvent pas utiliser l'attribut HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Cette règle se déclenche sur toute méthode transparente et tente de gérer une exception qui endommage un processus à l’aide de l’attribut HandleProcessCorruptedStateExceptionsAttribute. Une exception qui endommage un processus est une classification d’exception CLR version 4,0 d’exceptions comme <xref:System.AccessViolationException> . L’attribut HandleProcessCorruptedStateExceptionsAttribute peut uniquement être utilisé par des méthodes critiques de sécurité et sera ignoré s’il s’applique à une méthode transparente.|
|[CA2140 : Le code transparent ne doit pas faire référence à des éléments critiques de sécurité](../code-quality/ca2140.md)|Les méthodes marquées avec SecurityTransparentAttribute appellent des membres non publics marqués en tant que SecurityCritical. Cette règle analyse toutes les méthodes et tous les types d’un assembly qui sont transparents et critiques, et signale tous les appels du code transparent au code critique non public qui ne sont pas marqués SecurityTreatAsSafe.|
|[CA2141 : Les méthodes transparentes ne répondent pas aux LinkDemands](../code-quality/ca2141.md)|Une méthode transparente de sécurité appelle une méthode dans un assembly qui n’est pas marqué à l’aide de l’attribut APTCA (AllowPartiallyTrustedCallersAttribute), ou une méthode transparente de sécurité satisfait une demande LinkDemand pour un type ou une méthode.|
|[CA2142 : Le code transparent ne doit pas être protégé avec des LinkDemands](../code-quality/ca2142.md)|Cette règle se déclenche sur les méthodes transparentes qui requièrent l’accès de LinkDemands. Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations.|
|[CA2143 : Les méthodes transparentes ne doivent pas utiliser de demandes de sécurité](../code-quality/ca2143.md)|Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations. Le code transparent de sécurité doit utiliser des demandes complètes pour prendre des décisions de sécurité et le code critique sécurisé ne doit pas dépendre du code transparent pour l’exécution de ces demandes.|
|[CA2144 : Le code transparent ne doit pas charger d'assemblys depuis des tableaux d'octets](../code-quality/ca2144.md)|La révision de sécurité du code transparent n’est pas aussi complète que la révision de sécurité du code critique, car le code transparent ne peut pas exécuter d’actions relatives à la sécurité. Les assemblys chargés à partir d’un tableau d’octets peuvent ne pas être remarqués dans du code transparent, et ce tableau d’octets peut contenir du code critique, voire critique de sécurité, qui doit être audité.|
|[CA2145 : Les méthodes transparentes ne doivent pas être décorées avec SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Les méthodes décorées avec l’attribut SuppressUnmanagedCodeSecurityAttribute ont un LinkDemand implicite sur toute méthode qui l’appelle. Ce LinkDemand requiert que le code appelant soit critique de sécurité. Le marquage de la méthode qui utilise SuppressUnmanagedCodeSecurity avec l’attribut SecurityCriticalAttribute rend cette spécification plus évidente pour les appelants de la méthode.|
|[CA2146 : Les types doivent être au moins aussi critiques que les types de base et les interfaces](../code-quality/ca2146.md)|Cette règle se déclenche lorsqu’un type dérivé a un attribut de transparence de sécurité qui n’est pas aussi critique que son type de base ou l’interface implémentée. Seuls les types critiques peuvent dériver des types de base critiques ou implémenter des interfaces critiques, et seuls les types critiques ou critiques sécurisés peuvent dériver des types de base critiques sécurisés ou implémenter des interfaces critiques sécurisées.|
|[CA2147 : Les méthodes transparentes ne peuvent pas utiliser d’assertions de sécurité](../code-quality/ca2147.md)|Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est entièrement transparent ou mi-transparent et mi-critique, et elle signale toutes les utilisations déclaratives ou impératives d’Assert.|
|[CA2149 : Les méthodes transparentes ne doivent pas appeler du code natif](../code-quality/ca2149.md)|Cette règle se déclenche sur toute méthode transparente qui appelle directement en code natif, par exemple, via un appel P/Invoke. Les violations de cette règle provoquent une exception MethodAccessException dans le modèle de transparence de niveau 2, et une demande complète pour le code UnmanagedCode dans le modèle de transparence de niveau 1.|
|[CA2151 : Les champs avec des types critiques doivent être des champs critiques de sécurité](../code-quality/ca2151.md)|Pour utiliser les types critiques de sécurité, le code qui référence le type doit être critique de sécurité ou critique sécurisé. Ceci est vrai même si la référence est indirecte. Par conséquent, un champ transparent de sécurité ou critique sécurisé est trompeur, car le code transparent ne pourra toujours pas accéder au champ.|
|[CA2153 : Éviter la gestion des exceptions d’état endommagé](../code-quality/ca2153.md)|Les[exceptions d’état endommagé (CSE, Corrupted State Exceptions)](https://msdn.microsoft.com/magazine/dd419661.aspx) indiquent une altération de la mémoire dans votre processus. Le fait d’intercepter ces exceptions au lieu d’autoriser le processus à se bloquer peut engendrer des failles de sécurité si une personne malveillante réussit à placer une attaque dans la région de la mémoire endommagée.|
|[CA2300 : N’utilisez pas le désérialiseur non sécurisé BinaryFormatter](../code-quality/ca2300.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2301 : N’appelez pas BinaryFormatter.Deserialize sans définir BinaryFormatter.Binder au préalable](../code-quality/ca2301.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2302 : Vérifiez que BinaryFormatter.Binder est défini avant d’appeler BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2305 : N’utilisez pas le désérialiseur non sécurisé LosFormatter](../code-quality/ca2305.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2310 : N’utilisez pas le désérialiseur non sécurisé NetDataContractSerializer](../code-quality/ca2310.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2311 : Ne désérialisez pas sans définir d’abord NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2312 : Vérifiez que NetDataContractSerializer.Binder est défini avant la désérialisation](../code-quality/ca2312.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2315 : N’utilisez pas le désérialiseur non sécurisé ObjectStateFormatter](../code-quality/ca2315.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2321 : Ne désérialisez avec JavaScriptSerializer à l’aide de SimpleTypeResolver](../code-quality/ca2321.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2322 : Assurez-vous que JavaScriptSerializer n’est pas initialisé avec SimpleTypeResolver avant la désérialisation](../code-quality/ca2322.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2326 : N’utilisez pas de valeurs TypeNameHandling autres que None](../code-quality/ca2326.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2327 : N’utilisez pas de JsonSerializerSettings non sécurisés](../code-quality/ca2327.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2328 : Vérifiez que les JsonSerializerSettings sont sécurisés](../code-quality/ca2328.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2329 : Ne désérialisez pas avec JsonSerializer à l’aide d’une configuration non sécurisée](../code-quality/ca2329.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2330 : Vérifiez que JsonSerializer a une configuration sécurisée lors de la désérialisation.](../code-quality/ca2330.md)|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|[CA2350 : Vérifier que l’entrée de DataTable.ReadXml() est approuvée](ca2350.md)|Lors de la désérialisation d’un <xref:System.Data.DataTable> avec une entrée non fiable, une personne malveillante peut concevoir une entrée malveillante pour effectuer une attaque par déni de service. Il peut y avoir des vulnérabilités d’exécution de code à distance inconnues.|
|[CA2351 : Vérifier que l’entrée de DataSet.ReadXml() est approuvée](ca2351.md)|Lors de la désérialisation d’un <xref:System.Data.DataSet> avec une entrée non fiable, une personne malveillante peut concevoir une entrée malveillante pour effectuer une attaque par déni de service. Il peut y avoir des vulnérabilités d’exécution de code à distance inconnues.|
|[CA2352 : Un jeu de données ou une table de données non sécurisé(e) dans un type sérialisable peut être vulnérable aux attaques par exécution de code à distance](ca2352.md)|Une classe ou un struct marqué avec <xref:System.SerializableAttribute> contient un champ ou une <xref:System.Data.DataSet> <xref:System.Data.DataTable> propriété, et n’a pas de <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353 : Jeu de données ou table de données non sécurisé(e) dans un type sérialisable](ca2353.md)|Une classe ou un struct marqué avec un attribut de sérialisation XML ou un attribut de contrat de données contient un <xref:System.Data.DataSet> champ ou une <xref:System.Data.DataTable> propriété ou.|
|[CA2354 : Un jeu de données ou une table de données non sécurisé(e) dans un graphe d’objets désérialisé peut être vulnérable à une attaque par exécution de code à distance](ca2354.md)|La désérialisation avec un <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> sérialisé et le graphique d’objet du type casté peuvent inclure <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2355 : Jeu de données ou table de données non sécurisé(e) dans un graphe d’objets désérialisé](ca2355.md)|Désérialisation lorsque le graphique d’objets du type casté ou spécifié peut inclure un <xref:System.Data.DataSet> ou un <xref:System.Data.DataTable> .|
|[CA2356 : jeu de données ou DataTable non sécurisés dans le graphique d’objets désérialisés Web](ca2356.md)|Une méthode avec un <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> ou un <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> a un paramètre qui peut faire référence à un <xref:System.Data.DataSet> ou un <xref:System.Data.DataTable> .|
|[CA2361 : Vérifier que la classe générée automatiquement contenant DataSet.ReadXml() n'est pas utilisée avec des données non fiables](ca2361.md)|Lors de la désérialisation d’un <xref:System.Data.DataSet> avec une entrée non fiable, une personne malveillante peut concevoir une entrée malveillante pour effectuer une attaque par déni de service. Il peut y avoir des vulnérabilités d’exécution de code à distance inconnues.|
|[CA2362 : Un jeu de données ou une table de données non sécurisé dans un type sérialisable généré automatiquement peut être vulnérable aux attaques par exécution de code à distance](ca2362.md)|Lors de la désérialisation d’une entrée non approuvée avec <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> et que le graphique d’objets désérialisé contient <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> , une personne malveillante peut concevoir une charge utile malveillante pour effectuer une attaque d’exécution de code à distance.|
|[CA3001 : Passez en revue le code pour détecter les vulnérabilités de l’injection SQL](../code-quality/ca3001.md)|Lorsque vous utilisez des commandes d’entrée et SQL non fiables, tenez-vous à l’esprit des attaques par injection SQL. Une attaque par injection de SQL peut exécuter des commandes SQL malveillantes et compromettre la sécurité et l’intégrité de votre application.|
|[CA3002 : Passez en revue le code pour détecter les vulnérabilités des scripts XSS](../code-quality/ca3002.md)|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, gardez à l’esprit les attaques de script entre sites (XSS). Une attaque XSS injecte une entrée non fiable dans une sortie HTML brute, ce qui permet à la personne malveillante d’exécuter des scripts malveillants ou de modifier du contenu de manière malveillante dans votre page Web.|
|[CA3003 : Passez en revue le code pour détecter les vulnérabilités de l’injection de chemin de fichier](../code-quality/ca3003.md)|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, pensez à utiliser une entrée contrôlée par l’utilisateur lors de la spécification des chemins d’accès aux fichiers.|
|[CA3004 : Passez en revue le code pour détecter les vulnérabilités sur la divulgation d’informations](../code-quality/ca3004.md)|La divulgation d’informations sur les exceptions permet aux attaquants d’obtenir des informations sur les éléments internes de votre application, ce qui peut aider les attaquants à trouver d’autres vulnérabilités à exploiter.|
|[CA3006 : Passez en revue le code pour détecter les vulnérabilités de l’injection de commande de processus](../code-quality/ca3006.md)|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de commande. Une attaque par injection de commande peut exécuter des commandes malveillantes sur le système d’exploitation sous-jacent, compromettant ainsi la sécurité et l’intégrité de votre serveur.|
|[CA3007 : Passez en revue le code pour détecter les vulnérabilités de la redirection ouverte](../code-quality/ca3007.md)|Lors de l’utilisation d’une entrée non fiable, tenez à l’esprit des vulnérabilités de redirection ouvertes. Une personne malveillante peut exploiter une vulnérabilité de redirection ouverte pour utiliser votre site Web afin de fournir l’apparence d’une URL légitime, mais de rediriger un visiteur non suspect vers une autre page Web malveillante ou malveillante.|
|[CA3008 : Passez en revue le code pour détecter les vulnérabilités de l’injection XPath](../code-quality/ca3008.md)|Lors de l’utilisation d’une entrée non fiable, tenez-vous à l’esprit des attaques par injection XPath. La construction de requêtes XPath à l’aide d’une entrée non approuvée peut permettre à une personne malveillante de manipuler la requête de manière malveillante pour retourner un résultat inattendu et éventuellement divulguer le contenu du fichier XML interrogé.|
|[CA3009 : Passez en revue le code pour détecter les vulnérabilités de l’injection XML](../code-quality/ca3009.md)|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection XML.|
|[CA3010 : Passez en revue le code pour détecter les vulnérabilités de l’injection XAML](../code-quality/ca3010.md)|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de code XAML. Le XAML est un langage de balisage qui représente directement l’instanciation d’objets et leur exécution. Cela signifie que les éléments créés en XAML peuvent interagir avec les ressources système (par exemple, l’accès réseau et l’e/s du système de fichiers).|
|[CA3011 : Passez en revue le code pour détecter les vulnérabilités de l’injection de DLL](../code-quality/ca3011.md)|Lors de l’utilisation d’une entrée non fiable, pensez au chargement de code non fiable. Si votre application Web charge du code non fiable, une personne malveillante peut être en mesure d’injecter des dll malveillantes dans votre processus et d’exécuter du code malveillant.|
|[CA3012 : Passez en revue le code pour détecter les vulnérabilités de l’injection regex](../code-quality/ca3012.md)|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection de Regex. Une personne malveillante peut utiliser l’injection Regex pour modifier une expression régulière de manière malveillante, pour faire correspondre des résultats inattendus par l’expression régulière, ou pour faire en sorte que l’expression régulière consomme un processeur excessif, entraînant une attaque par déni de service.|
|[CA3061 : Ne pas ajouter de schéma par URL](../code-quality/ca3061.md)|N’utilisez pas la surcharge unsafe de la méthode Add, car elle peut provoquer des références externes dangereuses.|
|[CA3075 : Traitement DTD non sécurisé](../code-quality/ca3075.md)|Si vous utilisez des instances de DTDProcessing non sécurisées ou référencez des sources d’entités externes, l’analyseur peut accepter une entrée non fiable et divulguer des informations sensibles à des personnes malveillantes.|
|[CA3076 : Exécution non sécurisée de script XSLT](../code-quality/ca3076.md)|Si vous exécutez des transformations XSLT (Extensible Stylesheet Language Transformations) dans les applications .NET de manière non sécurisée, le processeur peut résoudre les références URI non fiables qui pourraient divulguer des informations sensibles à des attaquants, conduisant à des attaques par déni de service et intersites.|
|[CA3077 : Traitement non sécurisé dans la conception d’API, le document XML et le lecteur de texte XML](../code-quality/ca3077.md)|Lors de la conception d’une API dérivée de XMLDocument et XMLTextReader, tenez compte de DtdProcessing. L’utilisation d’instances de DTDProcessing non sécurisées lors de la référence ou la résolution de sources d’entités externes ou la définition de valeurs non sécurisées dans le code XML peut aboutir à la divulgation d’informations.|
|[CA3147 : Marquer les gestionnaires de verbe avec ValidateAntiForgeryToken](../code-quality/ca3147.md)|Lors de la conception d’un contrôleur MVC ASP.NET, soyez attentif aux attaques de falsification de requête intersites. Une attaque de falsification de requête intersite peut envoyer des demandes malveillantes d’un utilisateur authentifié à votre contrôleur ASP.NET MVC.|
|[Les déclarations P/Invoke CA5122 : ne doivent pas être critiques en toute sécurité](../code-quality/ca5122.md)|Les méthodes sont marquées SecuritySafeCritical lorsqu’elles effectuent une opération relative à la sécurité, mais elle peuvent également être utilisées en toute sécurité par du code transparent. Le code transparent peut ne jamais appeler directement du code natif via P/Invoke. Par conséquent, marquer une méthode P/Invoke comme critique sécurisé ne permet pas au code transparent de l’appeler et s’avère trompeur pour l’analyse de sécurité.|
|[CA5359 : Ne pas désactiver la validation de certificat](../code-quality/ca5359.md)|Un certificat peut aider à authentifier l’identité du serveur. Les clients doivent valider le certificat de serveur pour s’assurer que les demandes sont envoyées au serveur souhaité. Si le ServerCertificateValidationCallback retourne toujours `true` , les certificats sont validés.|
|[CA5360 : Ne pas appeler de méthodes dangereuses dans la désérialisation](../code-quality/ca5360.md)|Une désérialisation non sécurisée est une vulnérabilité qui se produit lorsque des données non approuvées sont utilisées pour abuser de la logique d’une application, provoquer une attaque par déni de service (DoS) ou même exécuter du code arbitraire sur la désérialisation. Il est souvent possible pour les utilisateurs malveillants d’abuser de ces fonctionnalités de désérialisation lorsque l’application désérialise des données non approuvées qui sont sous leur contrôle. Plus précisément, appelez des méthodes dangereuses dans le processus de désérialisation. Des attaques de désérialisation non sécurisées pourraient permettre à une personne malveillante d’effectuer des attaques telles que les attaques par déni de l’authentification, les contournements d’authentification et l’exécution de code à distance.|
|[CA5361 : Ne pas désactiver l’utilisation du chiffrement fort par SChannel](../code-quality/ca5361.md)|`Switch.System.Net.DontEnableSchUseStrongCrypto`Le paramètre pour `true` assouplit le chiffrement utilisé dans les connexions TLS (Transport Layer Security) sortantes. Un chiffrement plus faible peut compromettre la confidentialité de la communication entre votre application et le serveur, ce qui permet aux attaquants d’espionner facilement les données sensibles.|
|[CA5362 : Cycle de référence potentiel dans le graphe d’objets désérialisé](../code-quality/ca5362.md)|En cas de désérialisation de données non fiables, tout code qui traite le graphique d’objets désérialisé doit gérer les cycles de référence sans passer par des boucles infinies. Cela comprend à la fois le code qui fait partie d’un rappel de désérialisation et le code qui traite le graphique d’objet une fois la désérialisation terminée. Dans le cas contraire, une personne malveillante pourrait effectuer une attaque par déni de service avec des données malveillantes contenant un cycle de référence.|
|[CA5363 : Ne pas désactiver la validation de demandes](../code-quality/ca5363.md)|La validation de la demande est une fonctionnalité de ASP.NET qui examine les requêtes HTTP et détermine si elles contiennent du contenu potentiellement dangereux pouvant entraîner des attaques par injection, y compris des scripts inter-sites.|
|[CA5364 : Ne pas utiliser de protocoles de sécurité dépréciés](../code-quality/ca5364.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|[CA5365 : Ne pas désactiver la vérification des en-têtes HTTP](../code-quality/ca5365.md)|La vérification d’en-tête HTTP permet l’encodage des caractères de retour chariot et de saut de ligne, \r et \n, qui se trouvent dans les en-têtes de réponse. Cet encodage peut aider à éviter les attaques par injection qui exploitent une application qui renvoie les données non fiables contenues dans l’en-tête.|
|[CA5366 : Utiliser XmlReader pour lire les données XML d’un jeu de données](../code-quality/ca5366.md)|L’utilisation <xref:System.Data.DataSet> d’un pour lire des données XML avec des données non fiables peut charger des références externes dangereuses, qui doivent être limitées à l’aide d’un <xref:System.Xml.XmlReader> avec un résolveur sécurisé ou lorsque le traitement DTD est désactivé.|
|[CA5367 : Ne pas sérialiser les types avec des champs de pointeur](../code-quality/ca5367.md)|Cette règle vérifie s’il existe une classe sérialisable avec un champ ou une propriété de pointeur. Les membres qui ne peuvent pas être sérialisés peuvent être un pointeur, tel que des membres statiques ou des champs marqués avec <xref:System.NonSerializedAttribute> .|
|[CA5368 : Définir ViewStateUserKey pour les classes dérivées de Page](../code-quality/ca5368.md)|La définition de la <xref:System.Web.UI.Page.ViewStateUserKey> propriété peut vous aider à empêcher les attaques sur votre application en vous permettant d’affecter un identificateur à la variable d’état d’affichage pour les utilisateurs individuels afin que les attaquants ne puissent pas utiliser la variable pour générer une attaque. Dans le cas contraire, il y aura des vulnérabilités à la falsification de requête intersites.|
|[CA5369 : Utiliser XmlReader pour la désérialisation](../code-quality/ca5369.md)|Le traitement de schémas DTD et XML non fiables peut permettre le chargement de références externes dangereuses, qui doivent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|[CA5370 : Utiliser XmlReader pour la validation du lecteur](../code-quality/ca5370.md)|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. Ce chargement dangereux peut être restreint à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|[CA5371 : Utiliser XmlReader pour la lecture de schéma](../code-quality/ca5371.md)|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. L’utilisation d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement de schéma Inline XML désactivé restreint les restrictions.|
|[CA5372 : Utiliser XmlReader pour XPathDocument](../code-quality/ca5372.md)|Le traitement de code XML à partir de données non fiables peut charger des références externes dangereuses, qui peuvent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou lorsque le traitement DTD est désactivé.|
|[CA5373 : Ne pas utiliser la fonction de dérivation de clé obsolète](../code-quality/ca5373.md)|Cette règle détecte l’appel des méthodes de dérivation de clé faible <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> et `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> utilisé un algorithme PBKDF1 faible.|
|[CA5374 : Ne pas utiliser XslTransform](../code-quality/ca5374.md)|Cette règle vérifie si <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> est instancié dans le code. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> est désormais obsolète et ne doit pas être utilisé.|
|[CA5375 : Ne pas utiliser de signature d’accès partagé au compte](../code-quality/ca5375.md)|Une SAP de compte peut déléguer l’accès aux opérations de lecture, d’écriture et de suppression sur les conteneurs d’objets BLOB, les tables, les files d’attente et les partages de fichiers qui ne sont pas autorisés avec une SAP de service. Toutefois, il ne prend pas en charge les stratégies au niveau du conteneur et a moins de flexibilité et de contrôle sur les autorisations accordées. Une fois que les utilisateurs malveillants l’obtiennent, votre compte de stockage est facilement compromis.|
|[CA5376 : Utiliser SharedAccessProtocol HttpsOnly](../code-quality/ca5376.md)|La signature d’accès partagé est une donnée sensible qui ne peut pas être transportée en texte brut sur HTTP.|
|[CA5377 : Utiliser une stratégie d’accès au niveau du conteneur](../code-quality/ca5377.md)|Une stratégie d’accès au niveau du conteneur peut être modifiée ou révoquée à tout moment. Il offre une plus grande souplesse et un contrôle sur les autorisations accordées.|
|[CA5378 : Ne pas désactiver ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Le paramètre `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` pour `true` limite les connexions TLS (Transport Layer Security) de Windows Communication Framework (WCF) à l’utilisation de TLS 1,0. Cette version de TLS sera dépréciée.|
|[CA5379 : Ne pas utiliser l’algorithme de fonction de dérivation de clés faibles](../code-quality/ca5379.md)|La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe utilise par défaut l' <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithme. Vous devez spécifier l’algorithme de hachage à utiliser dans certaines surcharges du constructeur avec <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> ou une version ultérieure. Remarque : <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> la propriété a uniquement un `get` accesseur et n’a pas de `overriden` modificateur.|
|[CA5380 : Ne pas ajouter de certificats au magasin racine](../code-quality/ca5380.md)|Cette règle détecte le code qui ajoute un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui remplissent les conditions du programme de certification racine de Microsoft.|
|[CA5381 : S’assurer que les certificats ne sont pas ajoutés au magasin racine](../code-quality/ca5381.md)|Cette règle détecte le code qui ajoute potentiellement un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui répondent aux exigences du programme de certification racine de Microsoft.|
|[CA5382 : Utiliser des cookies sécurisés dans ASP.Net Core](../code-quality/ca5382.md)|Les applications disponibles sur HTTPs doivent utiliser des cookies sécurisés, qui indiquent au navigateur que le cookie doit être transmis uniquement à l’aide du protocole TLS (Transport Layer Security).|
|[CA5383 : Vérifier l’utilisation de cookies sécurisés dans ASP.Net Core](../code-quality/ca5383.md)|Les applications disponibles sur HTTPs doivent utiliser des cookies sécurisés, qui indiquent au navigateur que le cookie doit être transmis uniquement à l’aide du protocole TLS (Transport Layer Security).|
|[CA5384 : Ne pas utiliser DSA (Digital Signature Algorithm)](../code-quality/ca5384.md)|DSA est un algorithme de chiffrement asymétrique faible.|
|[CA5385 : Utiliser l’algorithme RSA (Rivest-Shamir-Adleman) avec une taille de clé suffisante](../code-quality/ca5385.md)|Une clé RSA inférieure à 2048 bits est plus vulnérable aux attaques par force brute.|
|[CA5386 : Éviter tout codage en dur de la valeur de SecurityProtocolType](../code-quality/ca5386.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour garantir la sécurité de votre application, évitez de coder en dur une version de protocole et ciblez au moins .NET Framework v 4.7.1.|
|[CA5387 : Ne pas utiliser la fonction de dérivation de clés faibles avec un nombre insuffisant d’itérations](../code-quality/ca5387.md)|Cette règle vérifie si une clé de chiffrement a été générée par <xref:System.Security.Cryptography.Rfc2898DeriveBytes> avec un nombre d’itérations inférieur à 100 000. Un nombre d’itérations plus élevé peut aider à atténuer les attaques de dictionnaire qui essaient de deviner la clé de chiffrement générée.|
|[CA5388 : Vérifier que le nombre d’itérations est suffisant lors de l’utilisation de la fonction de dérivation de clés faibles](../code-quality/ca5388.md)|Cette règle vérifie si une clé de chiffrement a été générée par <xref:System.Security.Cryptography.Rfc2898DeriveBytes> avec un nombre d’itérations qui peut être inférieur à 100 000. Un nombre d’itérations plus élevé peut aider à atténuer les attaques de dictionnaire qui essaient de deviner la clé de chiffrement générée.|
|[CA5389 : Ne pas ajouter le chemin de l’élément d’archive au chemin du système de fichiers cible](../code-quality/ca5389.md)|Le chemin d’accès de fichier peut être relatif et peut entraîner l’accès au système de fichiers en dehors du chemin d’accès cible du système de fichiers attendu, ce qui conduit à des modifications de configuration malveillantes et à l’exécution de code à distance par le biais d’une technique de mise en attente.|
|[CA5390 : Ne pas coder en dur la clé de chiffrement](../code-quality/ca5390.md)|Pour qu’un algorithme symétrique réussisse, la clé secrète doit être connue uniquement de l’expéditeur et du récepteur. Lorsqu’une clé est codée en dur, elle est facilement découverte. Même avec les fichiers binaires compilés, il est facile pour les utilisateurs malveillants de l’extraire. Une fois la clé privée compromise, le texte chiffré peut être déchiffré directement et n’est plus protégé.|
|[CA5391 : Utiliser des jetons antifalsification dans les contrôleurs ASP.NET Core MVC](../code-quality/ca5391.md)|La gestion d’une `POST` `PUT` demande,, `PATCH` ou `DELETE` sans validation d’un jeton anti-contrefaçon peut être vulnérable aux attaques de falsification de requête intersites. Une attaque de falsification de requête intersite peut envoyer des demandes malveillantes d’un utilisateur authentifié à votre contrôleur ASP.NET Core MVC.|
|[CA5392 : Utiliser l’attribut DefaultDllImportSearchPaths pour les P/Invokes](../code-quality/ca5392.md)|Par défaut, les fonctions P/Invoke utilisant <xref:System.Runtime.InteropServices.DllImportAttribute> sondent un certain nombre de répertoires, y compris le répertoire de travail actuel de la bibliothèque à charger. Il peut s’agir d’un problème de sécurité pour certaines applications, conduisant à un piratage de DLL.|
|[CA5393 : Ne pas utiliser de valeur DllImportSearchPath non sécurisée](../code-quality/ca5393.md)|Il peut y avoir une DLL malveillante dans les répertoires de recherche et les répertoires de l’assembly de la DLL par défaut. Ou, selon l’emplacement à partir duquel votre application est exécutée, il peut y avoir une DLL malveillante dans le répertoire de l’application.|
|[CA5394 : Ne pas utiliser de sélection aléatoire non sécurisée](../code-quality/ca5394.md)|L’utilisation d’un générateur de nombres pseudo-aléatoires faiblement faible peut permettre à une personne malveillante de prédire quelle valeur sensible à la sécurité sera générée.|
|[CA5395 : Attribut HttpVerb manquant pour les méthodes d’action](../code-quality/ca5395.md)|Toutes les méthodes d’action qui créent, modifient, suppriment ou modifient des données doivent être protégées avec l’attribut anti-contrefaçon des attaques de falsification de requête intersite. L’exécution d’une opération d’extraction doit être une opération sécurisée qui n’a pas d’effets secondaires et qui ne modifie pas vos données persistantes.|
|[CA5396 : Affecter la valeur true à HttpOnly pour HttpCookie](../code-quality/ca5396.md)|En guise de mesure de défense en profondeur, vérifiez que les cookies HTTP sensibles à la sécurité sont marqués comme HttpOnly. Cela indique que les navigateurs Web doivent autoriser les scripts à accéder aux cookies. Les scripts malveillants injectés sont un moyen courant de voler des cookies.|
|[CA5397 : Ne pas utiliser de valeurs SslProtocols dépréciées](../code-quality/ca5397.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|[CA5398 : Éviter les valeurs SslProtocols codées en dur](../code-quality/ca5398.md)|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour vous assurer que votre application reste sécurisée, évitez de coder en dur une version de protocole.|
|[CA5399 : Désactiver définitivement la vérification de la liste de révocation de certificats HttpClient](../code-quality/ca5399.md)|Un certificat révoqué n’est plus approuvé. Elle peut être utilisée par des attaquants qui transmettent des données malveillantes ou dérobent des données sensibles dans la communication HTTPs.|
|[CA5400 : Contrôler si la vérification de la liste de révocation de certificats HttpClient est bien activée](../code-quality/ca5400.md)|Un certificat révoqué n’est plus approuvé. Elle peut être utilisée par des attaquants qui transmettent des données malveillantes ou dérobent des données sensibles dans la communication HTTPs.|
|[CA5401 : Ne pas utiliser CreateEncryptor avec une valeur IV non définie par défaut](../code-quality/ca5401.md)|Le chiffrement symétrique doit toujours utiliser un vecteur d’initialisation non renouvelable pour empêcher les attaques de dictionnaire.|
|[CA5402 : Utiliser CreateEncryptor avec la valeur par défaut IV](../code-quality/ca5402.md)|Le chiffrement symétrique doit toujours utiliser un vecteur d’initialisation non renouvelable pour empêcher les attaques de dictionnaire.|
