---
title: Avertissements liés à la sécurité
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: bf1f318d8138bb455e965d7df44ae45e192904e3
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72018767"
---
# <a name="security-warnings"></a>Avertissements liés à la sécurité

Les avertissements de sécurité prennent en charge des bibliothèques et des applications plus sûres. Ces avertissements contribuent à empêcher la présence de défauts de sécurité dans votre programme. Si vous désactivez chacun de ces avertissements, vous devez indiquer clairement le motif de l’opération dans le code et également en informer le responsable de la sécurité désigné pour votre projet de développement.

## <a name="in-this-section"></a>Dans cette section

|Règle|Description|
|----------|-----------------|
|@NO__T 0CA2100 : Examiner les requêtes SQL pour les vulnérabilités de sécurité @ no__t-0|Une méthode définit la propriété System.Data.IDbCommand.CommandText à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode. Cette règle suppose que l’argument de chaîne contient des entrées d’utilisateur. Une chaîne de commande SQL construite à partir d’entrées d’utilisateur est vulnérable aux attaques d’injection SQL.|
|@NO__T 0CA2102 : Intercepter les exceptions non CLSCompliant dans les gestionnaires généraux @ no__t-0|Un membre dans un assembly qui n’est pas marqué avec RuntimeCompatibilityAttribute ou qui est marqué avec RuntimeCompatibility(WrapNonExceptionThrows = false) contient un bloc catch qui gère System.Exception et ne contient pas de bloc catch général immédiatement après.|
|@NO__T 0CA2103 : Vérifier la sécurité impérative @ no__t-0|Une méthode utilise la sécurité impérative et est susceptible de construire l’autorisation à l’aide d’informations d’état ou de valeurs de retour qui peuvent changer pendant que la demande est active. Utilisez la sécurité de déclaration dès que possible.|
|@NO__T 0CA2104 : Ne déclarez pas les types référence mutables en lecture seule @ no__t-0|Un type visible de l’extérieur contient un champ en lecture seule visible de l’extérieur qui constitue un type référence mutable. Un type mutable est un type dont les données d’instance peuvent être modifiées.|
|@NO__T 0CA2105 : Les champs de tableau ne doivent pas être en lecture seule @ no__t-0|Lorsque vous appliquez le modificateur en lecture seule (ReadOnly en Visual Basic) à un champ qui contient un tableau, ce champ ne peut pas être modifié pour référencer un tableau différent. Toutefois, les éléments du tableau stockés dans un champ en lecture seule peuvent être modifiés.|
|@NO__T 0CA2106 : Assertions sécurisées @ no__t-0|Une méthode déclare une autorisation et aucune vérification de sécurité n’est exécutée sur l’appelant. L’assertion d’une autorisation de sécurité effectuée sans vérification de sécurité peut rendre votre code vulnérable et facile à exploiter.|
|@NO__T 0CA2107 : Passer en revue les activités refuser et autoriser uniquement @ no__t-0|L’utilisation de la méthode PermitOnly et les actions de sécurité CodeAccessPermission. Deny doivent être utilisées uniquement par ceux qui ont une connaissance approfondie de la sécurité .NET. Le code qui utilise ces actions de sécurité doit subir une révision de sécurité.|
|@NO__T 0CA2108 : Passer en revue la sécurité déclarative sur les types valeur @ no__t-0|Un type valeur public ou protégé est sécurisé par l’accès aux données ou des demandes de liaison.|
|@NO__T 0CA2109 : Passer en revue les gestionnaires d’événements visibles @ no__t-0|Une méthode de gestion d’événements publique ou protégée a été détectée. Les méthodes de gestion d'événements ne doivent pas être exposées sauf nécessité absolue.|
|@NO__T 0CA2111 : Les pointeurs ne doivent pas être visibles @ no__t-0|Un pointeur n’est ni privé, ni interne ni en lecture seule. Un code malveillant peut modifier la valeur du pointeur, autorisant potentiellement l’accès aux emplacements arbitraires en mémoire ou provoquant des défaillances des applications ou du système.|
|@NO__T 0CA2112 : Les types sécurisés ne doivent pas exposer les champs @ no__t-0|Un type public ou protégé contient des champs publics et est sécurisé par des demandes de liaison. Si un code a accès à une instance d’un type sécurisé par une demande de liaison, ce code n’a pas besoin de satisfaire la demande de liaison pour accéder aux champs du type.|
|@NO__T 0CA2114 : La sécurité de la méthode doit être un sur-ensemble de type @ no__t-0|Pour une même action, une méthode ne doit pas présenter de sécurité déclarative à la fois au niveau méthode et au niveau type.|
|@NO__T 0CA2115 : Appelez GC. KeepAlive quand vous utilisez des ressources natives @ no__t-0|Cette règle détecte les erreurs susceptibles de se produire du fait qu’une ressource non managée est en cours de finalisation alors qu’elle est encore utilisée dans un code non managé.|
|@NO__T 0CA2116 : Les méthodes APTCA doivent uniquement appeler les méthodes APTCA @ no__t-0|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale, et lorsque cet assembly exécute un code dans un autre assembly qui n’autorise pas les appelants dotés d’une confiance partielle, il devient possible d’exploiter une faille dans la sécurité.|
|@NO__T 0CA2117 : Les types APTCA doivent uniquement étendre les types de base APTCA @ no__t-0|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale et lorsqu’un type présent dans l’assembly hérite d’un type qui n’autorise pas les appelants partiellement approuvés, une exploitation de la sécurité devient possible.|
|@NO__T 0CA2118 : Passez en revue les syntaxes SuppressUnmanagedCodeSecurityAttribute @ no__t-0|SuppressUnmanagedCodeSecurityAttribute modifie le comportement par défaut du système en matière de sécurité pour les membres qui exécutent le code non managé utilisant COM Interop ou l’appel de code non managé. Cet attribut est essentiellement utilisé pour accroître les performances ; toutefois, les gains de performance s’accompagnent de risques substantiels pour la sécurité.|
|@NO__T 0CA2119 : Scellez les méthodes qui satisfont les interfaces privées @ no__t-0|Un type public pouvant être hérité fournit une implémentation de méthode substituable d’une interface interne (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez la méthode d’être substituée en dehors de l’assembly.|
|@NO__T 0CA2120 : Sécuriser les constructeurs de sérialisation @ no__t-0|Ce type possède un constructeur qui accepte un objet System.Runtime.Serialization.SerializationInfo et un objet System.Runtime.Serialization.StreamingContext (la signature du constructeur de sérialisation). Ce constructeur n’est pas sécurisé par une vérification de la sécurité, mais au moins un des constructeurs normaux dans le type est sécurisé.|
|@NO__T 0CA2121 : Les constructeurs statiques doivent être privés](../code-quality/ca2121.md)|Le système appelle le constructeur statique avant la création de la première instance du type ou le référencement de tout membre statique. Si un constructeur statique n’est pas privé, il peut être appelé par un code autre que le système. Selon les opérations effectuées dans le constructeur, cette possibilité peut provoquer un comportement inattendu.|
|@NO__T 0CA2122 : N’exposez pas indirectement des méthodes avec des demandes de liaison @ no__t-0|Un membre public ou protégé a des demandes de liaison et est appelé par un membre qui ne procède à aucune vérification de la sécurité. Une demande de liaison vérifie uniquement les autorisations de l'appelant immédiat.|
|@NO__T 0CA2123 : Les demandes de liaison de substitution doivent être identiques à base @ no__t-0|Cette règle met en correspondance une méthode et sa méthode de base, qui est soit une interface, soit une méthode virtuelle dans un autre type, puis compare les demandes de liaison sur chacune. Si cette règle est violée, un appelant malveillant peut ignorer la demande de liaison simplement en appelant la méthode non protégée.|
|@NO__T 0CA2124 : Inclure dans un wrapper les clauses finally vulnérables dans Outer try @ no__t-0|Une méthode publique ou protégée contient un bloc try/finally. Le bloc finally semble réinitialiser l’état de sécurité et n’est lui-même placé dans aucun bloc finally.|
|@NO__T 0CA2126 : Les demandes de liaison de type requièrent des demandes d’héritage @ no__t-0|Un type unsealed public est protégé par une demande de liaison et a une méthode substituable. Ni le type ni la méthode n’est protégé par une demande d’héritage.|
|@NO__T 0CA2130 : Les constantes critiques de sécurité doivent être transparentes @ no__t-0|La mise en application de la transparence n’est pas effectuée pour les valeurs de constante car les compilateurs alignent les valeurs de constante afin qu’aucune recherche ne soit requise au moment de l’exécution. Les champs constants doivent être transparents de sécurité (security-transparent) afin que les relecteurs de code ne supposent pas que le code transparent ne peut pas accéder à la constante.|
|@NO__T 0CA2131 : Les types critiques de sécurité ne peuvent pas participer à l’équivalence de type @ no__t-0|Un type participe à l’équivalence de type et le type lui-même, ou un membre ou champ du type, est marqué avec l’attribut SecurityCriticalAttribute. Cette règle se déclenche sur tout type ou type critique contenant des méthodes critiques ou des champs qui participent à l’équivalence de type. Lorsque le CLR détecte un tel type, il ne peut pas le charger avec une exception TypeLoadException au moment de l’exécution. En général, cette règle se déclenche uniquement lorsque les utilisateurs implémentent l’équivalence de type manuellement plutôt qu’en comptant sur tlbimp et les compilateurs pour faire l’équivalence de type.|
|@NO__T 0CA2132 : Les constructeurs par défaut doivent être au moins aussi critiques que les constructeurs par défaut de type de base @ no__t-0|Les types et les membres qui possèdent l’attribut SecurityCriticalAttribute ne peuvent pas être utilisés par le code d’application Silverlight. Les types et membres critiques de sécurité (security-critical) peuvent être uniquement utilisés par le code de confiance dans la bibliothèque de classes .NET Framework pour Silverlight. Dans la mesure où une construction publique ou protégée dans une classe dérivée doit avoir la même transparence ou une transparence supérieure à sa classe de base, une classe dans une application ne peut pas être dérivée d’une classe marquée SecurityCritical.|
|@NO__T 0CA2133 : Les délégués doivent être liés aux méthodes avec une transparence cohérente @ no__t-0|Cet avertissement se déclenche sur une méthode qui lie un délégué marqué à l’aide de SecurityCriticalAttribute à une méthode transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. L’avertissement déclenche également une méthode qui lie un délégué transparent ou critique sécurisé à une méthode critique.|
|@NO__T 0CA2134 : Les méthodes doivent conserver une transparence cohérente lors du remplacement des méthodes de base @ no__t-0|Cette règle se déclenche lorsqu’une méthode marquée à l’aide de SecurityCriticalAttribute substitue une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. Cette règle se déclenche également lorsqu’une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute substitue une méthode marquée à l’aide de SecurityCriticalAttribute. La règle est appliquée lors de la substitution d’une méthode virtuelle ou de l’implémentation d’une interface.|
|@NO__T 0CA2135 : Les assemblys de niveau 2 ne doivent pas contenir LinkDemands @ no__t-0|L’utilisation de LinkDemands est déconseillée dans l’ensemble de règles de sécurité de niveau 2. Au lieu d’utiliser LinkDemands pour implémenter la sécurité au moment de la compilation juste-à-temps (JIT), marquez les méthodes, types et champs avec l’attribut SecurityCriticalAttribute.|
|@NO__T 0CA2136 : Les membres ne doivent pas avoir d’annotations de transparence en conflit @ no__t-0|Les attributs de transparence sont appliqués à partir d’éléments de code de plus grande portée à des éléments de plus petite portée. Les attributs de transparence d’éléments de code avec une plus grande portée sont prioritaires sur les attributs de transparence des éléments de code contenus dans le premier élément. Par exemple, une classe marquée à l’aide de l’attribut SecurityCriticalAttribute ne peut pas contenir de méthode marquée à l’aide de l’attribut SecuritySafeCriticalAttribute.|
|@NO__T 0CA2137 : Les méthodes transparentes doivent contenir uniquement le langage intermédiaire vérifiable @ no__t-0|Une méthode contient du code non vérifiable ou retourne un type par référence. Cette règle se déclenche lorsque le code transparent de sécurité tente d’exécuter du code MSIL (Microsoft Intermediate Language) non vérifiable. Toutefois, la règle ne contient pas de vérificateur IL (Intermediate Language) complet, et à la place utilise l’heuristique pour intercepter la plupart des violations de vérification MSIL.|
|@NO__T 0CA2138 : Les méthodes transparentes ne doivent pas appeler de méthodes avec l’attribut SuppressUnmanagedCodeSecurity @ no__t-0|Une méthode transparente de sécurité appelle une méthode qui est marquée à l’aide de l’attribut SuppressUnmanagedCodeSecurityAttribute.|
|@NO__T 0CA2139 : Les méthodes transparentes ne peuvent pas utiliser l’attribut HandleProcessCorruptingExceptions @ no__t-0|Cette règle se déclenche sur toute méthode transparente et tente de gérer une exception qui endommage un processus à l’aide de l’attribut HandleProcessCorruptedStateExceptionsAttribute. Une exception qui endommage un processus est une classification d’exception CLR version 4,0 d’exceptions comme <xref:System.AccessViolationException>. L’attribut HandleProcessCorruptedStateExceptionsAttribute peut uniquement être utilisé par des méthodes critiques de sécurité et sera ignoré s’il s’applique à une méthode transparente.|
|@NO__T 0CA2140 : Le code transparent ne doit pas faire référence à des éléments critiques de sécurité @ no__t-0|Les méthodes marquées avec SecurityTransparentAttribute appellent des membres non publics marqués en tant que SecurityCritical. Cette règle analyse toutes les méthodes et tous les types d’un assembly qui sont transparents et critiques, et signale tous les appels du code transparent au code critique non public qui ne sont pas marqués SecurityTreatAsSafe.|
|[CA2141 : Les méthodes transparentes ne satisfont pas les LinkDemands](../code-quality/ca2141.md)|Une méthode transparente de sécurité appelle une méthode dans un assembly qui n’est pas marqué à l’aide de l’attribut APTCA (AllowPartiallyTrustedCallersAttribute), ou une méthode transparente de sécurité satisfait une demande LinkDemand pour un type ou une méthode.|
|@NO__T 0CA2142 : Le code transparent ne doit pas être protégé avec LinkDemands @ no__t-0|Cette règle se déclenche sur les méthodes transparentes qui requièrent l’accès de LinkDemands. Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations.|
|@NO__T 0CA2143 : Les méthodes transparentes ne doivent pas utiliser de demandes de sécurité @ no__t-0|Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations. Le code transparent de sécurité doit utiliser des demandes complètes pour prendre des décisions de sécurité et le code critique sécurisé ne doit pas dépendre du code transparent pour l’exécution de ces demandes.|
|@NO__T 0CA2144 : Le code transparent ne doit pas charger d’assemblys à partir de tableaux d’octets @ no__t-0|La révision de sécurité du code transparent n’est pas aussi complète que la révision de sécurité du code critique, car le code transparent ne peut pas exécuter d’actions relatives à la sécurité. Les assemblys chargés à partir d’un tableau d’octets peuvent ne pas être remarqués dans du code transparent, et ce tableau d’octets peut contenir du code critique, voire critique de sécurité, qui doit être audité.|
|@NO__T 0CA2145 : Les méthodes transparentes ne doivent pas être décorées avec SuppressUnmanagedCodeSecurityAttribute @ no__t-0|Les méthodes décorées avec l’attribut SuppressUnmanagedCodeSecurityAttribute ont un LinkDemand implicite sur toute méthode qui l’appelle. Ce LinkDemand requiert que le code appelant soit critique de sécurité. Le marquage de la méthode qui utilise SuppressUnmanagedCodeSecurity avec l’attribut SecurityCriticalAttribute rend cette spécification plus évidente pour les appelants de la méthode.|
|@NO__T 0CA2146 : Les types doivent être au moins aussi critiques que leurs types de base et interfaces @ no__t-0|Cette règle se déclenche lorsqu’un type dérivé a un attribut de transparence de sécurité qui n’est pas aussi critique que son type de base ou l’interface implémentée. Seuls les types critiques peuvent dériver des types de base critiques ou implémenter des interfaces critiques, et seuls les types critiques ou critiques sécurisés peuvent dériver des types de base critiques sécurisés ou implémenter des interfaces critiques sécurisées.|
|@NO__T 0CA2147 : Les méthodes transparentes ne peuvent pas utiliser des assertions de sécurité @ no__t-0|Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est entièrement transparent ou mi-transparent et mi-critique, et elle signale toutes les utilisations déclaratives ou impératives d’Assert.|
|@NO__T 0CA2149 : Les méthodes transparentes ne doivent pas appeler du code natif @ no__t-0|Cette règle se déclenche sur toute méthode transparente qui appelle directement en code natif, par exemple, via un appel P/Invoke. Les violations de cette règle provoquent une exception MethodAccessException dans le modèle de transparence de niveau 2, et une demande complète pour le code UnmanagedCode dans le modèle de transparence de niveau 1.|
|@NO__T 0CA2151 : Les champs avec des types critiques doivent être critiques pour la sécurité @ no__t-0|Pour utiliser les types critiques de sécurité, le code qui référence le type doit être critique de sécurité ou critique sécurisé. Ceci est vrai même si la référence est indirecte. Par conséquent, un champ transparent de sécurité ou critique sécurisé est trompeur, car le code transparent ne pourra toujours pas accéder au champ.|
|@NO__T 0CA2153 : Évitez de gérer les exceptions d’état endommagé @ no__t-0|Les[exceptions d’état endommagé (CSE, Corrupted State Exceptions)](https://msdn.microsoft.com/magazine/dd419661.aspx) indiquent une altération de la mémoire dans votre processus. Le fait d’intercepter ces exceptions au lieu d’autoriser le processus à se bloquer peut engendrer des failles de sécurité si une personne malveillante réussit à placer une attaque dans la région de la mémoire endommagée.|
|@NO__T 0CA2300 : N’utilisez pas le désérialiseur non sécurisé BinaryFormatter @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2301 : N’appelez pas BinaryFormatter. Deserialize sans définir au préalable BinaryFormatter. Binder @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2302 : Vérifiez que BinaryFormatter. Binder est défini avant d’appeler BinaryFormatter. désérialiser @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2305 : Ne pas utiliser le désérialiseur non sécurisé LosFormatter @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2310 : Ne pas utiliser le désérialiseur non sécurisé NetDataContractSerializer @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2311 : Ne pas désérialiser sans définir au préalable NetDataContractSerializer. Binder @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2312 : Vérifiez que NetDataContractSerializer. Binder est défini avant de désérialiser @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2315 : Ne pas utiliser le désérialiseur non sécurisé ObjectStateFormatter @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2321 : Ne pas désérialiser avec JavaScriptSerializer à l’aide d’un SimpleTypeResolver @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2322 : Vérifiez que JavaScriptSerializer n’est pas initialisé avec SimpleTypeResolver avant de désérialiser @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2326 : N’utilisez pas de valeurs TypeNameHandling autres que None @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2327 : N’utilisez pas JsonSerializerSettings @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2328 : Vérifier que les JsonSerializerSettings sont sécurisés @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2329 : Ne pas désérialiser avec JsonSerializer à l’aide d’une configuration non sécurisée @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA2330 : Vérifiez que JsonSerializer a une configuration sécurisée lors de la désérialisation de @ no__t-0|Les désérialiseurs non sécurisés sont vulnérables lors de la désérialisation des données non approuvées. Une personne malveillante peut modifier les données sérialisées pour inclure des types inattendus afin d’injecter des objets avec des effets secondaires malveillants.|
|@NO__T 0CA3001 : Examiner le code pour les vulnérabilités d’injection SQL @ no__t-0|Lorsque vous utilisez des commandes d’entrée et SQL non fiables, tenez-vous à l’esprit des attaques par injection SQL. Une attaque par injection de SQL peut exécuter des commandes SQL malveillantes et compromettre la sécurité et l’intégrité de votre application.|
|@NO__T 0CA3002 : Passer en revue le code pour les vulnérabilités XSS @ no__t-0|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, gardez à l’esprit les attaques de script entre sites (XSS). Une attaque XSS injecte une entrée non fiable dans une sortie HTML brute, ce qui permet à la personne malveillante d’exécuter des scripts malveillants ou de modifier du contenu de manière malveillante dans votre page Web.|
|@NO__T 0CA3003 : Examiner le code pour les vulnérabilités d’injection de chemin de fichier @ no__t-0|Lorsque vous travaillez avec des entrées non approuvées à partir de requêtes Web, pensez à utiliser une entrée contrôlée par l’utilisateur lors de la spécification des chemins d’accès aux fichiers.|
|@NO__T 0CA3004 : Consulter le code pour les vulnérabilités de divulgation d’informations @ no__t-0|La divulgation d’informations sur les exceptions permet aux attaquants d’obtenir des informations sur les éléments internes de votre application, ce qui peut aider les attaquants à trouver d’autres vulnérabilités à exploiter.|
|@NO__T 0CA3006 : Passer en revue le code pour traiter les vulnérabilités d’injection de commande @ no__t-0|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de commande. Une attaque par injection de commande peut exécuter des commandes malveillantes sur le système d’exploitation sous-jacent, compromettant ainsi la sécurité et l’intégrité de votre serveur.|
|@NO__T 0CA3007 : Vérifier le code pour les vulnérabilités de redirection ouvertes @ no__t-0|Lors de l’utilisation d’une entrée non fiable, tenez à l’esprit des vulnérabilités de redirection ouvertes. Une personne malveillante peut exploiter une vulnérabilité de redirection ouverte pour utiliser votre site Web afin de fournir l’apparence d’une URL légitime, mais de rediriger un visiteur non suspect vers une autre page Web malveillante ou malveillante.|
|@NO__T 0CA3008 : Examiner le code pour les vulnérabilités d’injection XPath @ no__t-0|Lors de l’utilisation d’une entrée non fiable, tenez-vous à l’esprit des attaques par injection XPath. La construction de requêtes XPath à l’aide d’une entrée non approuvée peut permettre à une personne malveillante de manipuler la requête de manière malveillante pour retourner un résultat inattendu et éventuellement divulguer le contenu du fichier XML interrogé.|
|@NO__T 0CA3009 : Examiner le code pour les vulnérabilités d’injection XML @ no__t-0|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection XML.|
|@NO__T 0CA3010 : Examiner le code pour les vulnérabilités d’injection XAML @ no__t-0|Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de code XAML. Le XAML est un langage de balisage qui représente directement l’instanciation d’objets et leur exécution. Cela signifie que les éléments créés en XAML peuvent interagir avec les ressources système (par exemple, l’accès réseau et l’e/s du système de fichiers).|
|@NO__T 0CA3011 : Examiner le code pour les vulnérabilités d’injection de DLL @ no__t-0|Lors de l’utilisation d’une entrée non fiable, pensez au chargement de code non fiable. Si votre application Web charge du code non fiable, une personne malveillante peut être en mesure d’injecter des dll malveillantes dans votre processus et d’exécuter du code malveillant.|
|@NO__T 0CA3012 : Examiner le code pour les vulnérabilités d’injection Regex @ no__t-0|Lorsque vous travaillez avec des entrées non fiables, soyez attentif aux attaques par injection de Regex. Une personne malveillante peut utiliser l’injection Regex pour modifier une expression régulière de manière malveillante, pour faire correspondre des résultats inattendus par l’expression régulière, ou pour faire en sorte que l’expression régulière consomme un processeur excessif, entraînant une attaque par déni de service.|
|@NO__T 0CA3061 : Ne pas ajouter de schéma par URL @ no__t-0|N’utilisez pas la surcharge unsafe de la méthode Add, car elle peut provoquer des références externes dangereuses.|
|@NO__T 0CA3075 : Traitement DTD non sécurisé @ no__t-0|Si vous utilisez des instances de DTDProcessing non sécurisées ou référencez des sources d’entités externes, l’analyseur peut accepter une entrée non fiable et divulguer des informations sensibles à des personnes malveillantes.|
|@NO__T 0CA3076 : Exécution du script XSLT non sécurisée @ no__t-0|Si vous exécutez le langage XSLT (Extensible Stylesheet Language Transformations) dans les applications .NET de manière non sécurisée, le processeur peut résoudre les références URI non fiables qui pourraient divulguer des informations sensibles à des personnes malveillantes, ce qui aboutirait à des attaques par déni de service et intersites.|
|@NO__T 0CA3077 : Traitement non sécurisé dans la conception d’API, le document XML et le lecteur de texte XML @ no__t-0|Lors de la conception d’une API dérivée de XMLDocument et XMLTextReader, tenez compte de DtdProcessing. L’utilisation d’instances de DTDProcessing non sécurisées lors de la référence ou la résolution de sources d’entités externes ou la définition de valeurs non sécurisées dans le code XML peut aboutir à la divulgation d’informations.|
|@NO__T 0CA3147 : Marquer des gestionnaires de verbe avec ValidateAntiForgeryToken @ no__t-0|Lors de la conception d’un contrôleur MVC ASP.NET, soyez attentif aux attaques de falsification de requête intersites. Une attaque de falsification de requête intersite peut envoyer des demandes malveillantes d’un utilisateur authentifié à votre contrôleur ASP.NET MVC.|
|[CA5122 : Les déclarations P-Invoke ne doivent pas être critiques sécurisées](../code-quality/ca5122.md)|Les méthodes sont marquées SecuritySafeCritical lorsqu’elles effectuent une opération relative à la sécurité, mais elle peuvent également être utilisées en toute sécurité par du code transparent. Le code transparent peut ne jamais appeler directement du code natif via P/Invoke. Par conséquent, marquer une méthode P/Invoke comme critique sécurisé ne permet pas au code transparent de l’appeler et s’avère trompeur pour l’analyse de sécurité.|
|@NO__T 0CA5361 : Ne désactivez pas l’utilisation de SChannel de chiffrement fort @ no__t-0|L’affectation de la valeur `Switch.System.Net.DontEnableSchUseStrongCrypto` à `true` assouplit le chiffrement utilisé dans les connexions TLS (Transport Layer Security) sortantes. Un chiffrement plus faible peut compromettre la confidentialité de la communication entre votre application et le serveur, ce qui permet aux attaquants d’espionner facilement les données sensibles.|
|@NO__T 0CA5363 : Ne pas désactiver la validation de la demande @ no__t-0|La validation de la demande est une fonctionnalité de ASP.NET qui examine les requêtes HTTP et détermine si elles contiennent du contenu potentiellement dangereux pouvant entraîner des attaques par injection, y compris des scripts inter-sites.|
|@NO__T 0CA5364 : Ne pas utiliser les protocoles de sécurité déconseillés @ no__t-0|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|@NO__T 0CA5369 : Utiliser XmlReader pour désérialiser @ no__t-0|Le traitement de schémas DTD et XML non fiables peut permettre le chargement de références externes dangereuses, qui doivent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|@NO__T 0CA5370 : Utiliser XmlReader pour valider le lecteur @ no__t-0|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. Ce chargement dangereux peut être restreint à l’aide d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement du schéma Inline XML désactivé.|
|@NO__T 0CA5371 : Utiliser XmlReader pour la lecture de schéma @ no__t-0|Le traitement des DTD et des schémas XML non fiables peut permettre le chargement de références externes dangereuses. L’utilisation d’un XmlReader avec un programme de résolution sécurisé ou avec la DTD et le traitement de schéma Inline XML désactivé restreint les restrictions.|
|@NO__T 0CA5372 : Utiliser XmlReader pour XPathDocument @ no__t-0|Le traitement de code XML à partir de données non fiables peut charger des références externes dangereuses, qui peuvent être limitées à l’aide d’un XmlReader avec un programme de résolution sécurisé ou lorsque le traitement DTD est désactivé.|
|@NO__T 0CA5373 : N’utilisez pas la fonction de dérivation de clé obsolète @ no__t-0|Cette règle détecte l’appel des méthodes de dérivation de clé faible <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> et `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> a utilisé un algorithme PBKDF1 faible.|
|@NO__T 0CA5378 : Ne désactivez pas ServicePointManagerSecurityProtocols @ no__t-0|La définition de `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` à `true` limite les connexions TLS (Transport Layer Security) de Windows Communication Framework (WCF) à l’utilisation de TLS 1,0. Cette version de TLS sera dépréciée.|
|@NO__T 0CA5380 : Ne pas ajouter de certificats au magasin racine @ no__t-0|Cette règle détecte le code qui ajoute un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui remplissent les conditions du programme de certification racine de Microsoft.|
|@NO__T 0CA5381 : Vérifier que les certificats ne sont pas ajoutés au magasin racine @ no__t-0|Cette règle détecte le code qui ajoute potentiellement un certificat dans le magasin de certificats des autorités de certification racines de confiance. Par défaut, le magasin de certificats des autorités de certification racines de confiance est configuré avec un ensemble d’autorités de certification publiques qui répondent aux exigences du programme de certification racine de Microsoft.|
|@NO__T 0CA5386 : Éviter le codage en dur de la valeur SecurityProtocolType @ no__t-0|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour garantir la sécurité de votre application, évitez de coder en dur une version de protocole et ciblez au moins .NET Framework v 4.7.1.|
|@NO__T 0CA5389 : N’ajoutez pas le chemin d’accès de l’élément d’archive au chemin d’accès du système de fichiers cible @ no__t-0|Le chemin d’accès de fichier peut être relatif et peut entraîner l’accès au système de fichiers en dehors du chemin d’accès cible du système de fichiers attendu, ce qui conduit à des modifications de configuration malveillantes et à l’exécution de code à distance par le biais d’une technique de mise en attente.|
|@NO__T 0CA5397 : N’utilisez pas les valeurs SslProtocols dépréciées @ no__t-0|ransport Layer Security (TLS) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les anciennes versions de protocole TLS sont moins sécurisées que TLS 1,2 et TLS 1,3 et sont plus susceptibles d’avoir de nouvelles vulnérabilités. Évitez les anciennes versions de protocole pour réduire les risques.|
|@NO__T 0CA5398 : Évitez les valeurs SslProtocols codées en dur @ no__t-0|TLS (Transport Layer Security) sécurise la communication entre les ordinateurs, le plus souvent avec le protocole HTTPs (Hypertext Transfer Protocol Secure). Les versions de protocole TLS 1,0 et TLS 1,1 sont dépréciées, tandis que TLS 1,2 et TLS 1,3 sont à jour. À l’avenir, TLS 1,2 et TLS 1,3 peuvent être déconseillés. Pour vous assurer que votre application reste sécurisée, évitez de coder en dur une version de protocole.|
