---
title: C28182
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C28182
helpviewer_keywords:
- C28182
ms.assetid: efec8b1f-8994-4a09-aaaf-6afaadfde883
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 42ca9d69cb4186ae82f71bf0014b27bb0101d253
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72015108"
---
# <a name="c28182"></a>C28182
AVERTISSEMENT C28182 : Déréférencement du pointeur NULL.

 **Informations supplémentaires**: *@no__t > 2pointer1* contient la même valeur null que *\<pointer2 >* ne @no__t *-6Note >*

 L’outil d’analyse du code signale cet avertissement lorsqu’il confirme que le pointeur peut être NULL. S’il existe des instances non confirmées où l’erreur peut se produire plus tôt dans la trace, l’outil d’analyse du code ajoute le numéro de ligne de la première instance au message d’avertissement afin que vous puissiez modifier le code pour traiter toutes les instances.

 *\<pointer2 >* est confirmée comme potentiellement null. *\<pointer1 >* contient la même valeur que *pointer2* et est en cours de déréférencement. Étant donné que ces pointeurs peuvent se trouver à des endroits différents dans le code, ils sont tous deux signalés pour vous permettre de déterminer la raison pour laquelle l’outil d’analyse du code signale cet avertissement.

 Si une instance antérieure non confirmée de la condition existe, *\<remarque >* est remplacé par le texte suivant : « Consultez Line *\<number >* à un emplacement antérieur où cela peut se produire. »

## <a name="example"></a>Exemple
 L’exemple suivant montre le code qui peut entraîner la génération de ce message d’avertissement par l’outil d’analyse du code. Dans cet exemple, l’outil d’analyse du code détermine que `pNodeFree` a la valeur NULL dans l’instruction `if`, et le chemin de code dans le corps de la `if` est pris. Toutefois, étant donné que `nBlockSize` est potentiellement zéro, le corps de l’instruction `for` n’est pas exécuté et `pNodeFree` n’est pas modifié. `pNodeFree` est ensuite affecté à `pNode`, et `pNode` est utilisé alors qu’un déréférencement NULL peut se produire.

```
typedef struct xlist {
    struct xlist *pNext;
    struct xlist *pPrev;
} list;

list *pNodeFree;
list *masterList;
int nBlockSize;

void fun()
{
    if (pNodeFree == 0)
    {
        list *pNode = masterList;

        for (int i = nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = pNodeFree;
            pNodeFree = pNode;
        }
    }

    list* pNode = pNodeFree;
    pNode->pPrev = 0;
}
```

 L’outil d’analyse du code signale l’avertissement suivant :

```
:\sample\testfile.cpp(24) : warning C28182: Dereferencing NULL pointer. 'pNode' contains the same NULL value as 'pNodeFree' did.: Lines: 12, 14, 16, 23, 24
```

## <a name="example"></a>Exemple
 Une façon de corriger l’exemple précédent consiste à vérifier `pNode` pour zéro avant de le déréférencer afin qu’une déréférencement NULL soit AVERT. Le code suivant illustre cette correction.

```
typedef struct xlist {
    struct xlist *pNext;
    struct xlist *pPrev;
} list;

list *pNodeFree;
list *masterList;
int nBlockSize;

void fun()
{
    if (pNodeFree == 0)
    {
        list *pNode = masterList;

        for (int i = nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = pNodeFree;
            pNodeFree = pNode;
        }
    }

    list* pNode = pNodeFree;
    if(pNode != 0)
      pNode->pPrev = 0;
}
```