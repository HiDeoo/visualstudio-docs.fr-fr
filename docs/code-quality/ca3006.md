---
title: 'Ca3006 : passez en revue le code pour traiter les vulnérabilités d’injection de commande'
ms.date: 04/03/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 8dea187d70c827e1cf4e880f34c8c0ab81d95789
ms.sourcegitcommit: c222052906362bf1a3762ec4d4623170e4e06702
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/04/2019
ms.locfileid: "74809906"
---
# <a name="ca3006-review-code-for-process-command-injection-vulnerabilities"></a>Ca3006 : passez en revue le code pour traiter les vulnérabilités d’injection de commande

|||
|-|-|
|TypeName|ReviewCodeForProcessCommandInjectionVulnerabilities|
|CheckId|CA3006|
|Category|Microsoft.Security|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une entrée de requête HTTP potentiellement non approuvée atteint une commande Process.

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

## <a name="rule-description"></a>Description de la règle

Lorsque vous travaillez avec des entrées non fiables, tenez-vous à l’esprit des attaques par injection de commande. Une attaque par injection de commande peut exécuter des commandes malveillantes sur le système d’exploitation sous-jacent, compromettant ainsi la sécurité et l’intégrité de votre serveur.

Cette règle tente de trouver une entrée à partir des requêtes HTTP qui atteignent une commande Process.

> [!NOTE]
> Cette règle ne peut pas effectuer le suivi des données dans les assemblys. Par exemple, si un assembly lit l’entrée de la requête HTTP, puis le passe à un autre assembly qui démarre un processus, cette règle ne génère pas d’avertissement.

> [!NOTE]
> Il existe une limite configurable de la profondeur de cette règle pour analyser le workflow des données entre les appels de méthode. Consultez [configuration de l’analyseur](https://github.com/dotnet/roslyn-analyzers/blob/master/docs/Analyzer%20Configuration.md#dataflow-analysis) pour savoir comment configurer la limite dans un fichier baEditorConfig.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

- Si possible, évitez de démarrer les processus en fonction de l’entrée de l’utilisateur.
- Valider l’entrée par rapport à un ensemble de caractères et une longueur connus.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Si vous savez que l’entrée a été validée ou placée dans une séquence d’échappement pour être sécurisée, il est possible de supprimer cet avertissement en toute sécurité.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir d' [analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), vous pouvez configurer l’analyse pour cette règle.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType`, ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA3006.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
  - `.ctor` pour les constructeurs et les `.cctor` pour les constructeurs statiques

Exemples :

| Valeur d’option | Récapitulatif |
| --- | --- |
|`dotnet_code_quality.CA3006.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA3006.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA3006.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA3006.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (sécurité). Pour plus d’informations, consultez [configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Exemples de pseudo-code

### <a name="violation"></a>Violation

```csharp
using System;
using System.Diagnostics;

public partial class WebForm : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        string input = Request.Form["in"];
        Process p = Process.Start(input);
    }
}
```

```vb
Imports System
Imports System.Diagnostics

Partial Public Class WebForm
    Inherits System.Web.UI.Page

    Protected Sub Page_Load(sender As Object, eventArgs as EventArgs)
        Dim input As String = Me.Request.Form("in")
        Dim p As Process = Process.Start(input)
    End Sub
End Class
```
