---
title: C6278
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6278
helpviewer_keywords:
- C6278
ms.assetid: 5cc3c393-c48a-4f91-9f38-03d7868be5e5
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 76578f8a1bfde5fb8d4444f749d9a921566bc4a5
ms.sourcegitcommit: 485ffaedb1ade71490f11cf05962add1718945cc
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/16/2019
ms.locfileid: "72447792"
---
# <a name="c6278"></a>C6278
AVERTISSEMENT C6278 : \<variable > est alloué avec un tableau New [], mais supprimé avec une variable scalaire Delete. Les destructeurs ne sont pas appelés

Cet avertissement s’affiche uniquement C++ dans le code et indique que la fonction appelante a alloué de manière incohérente la mémoire avec le tableau **New []** , mais l’a libéré avec l’opérateur scalaire **Delete** . Il s’agit d’un C++ comportement non défini en fonction des implémentations standard C++ et Microsoft Visual. Il existe au moins trois raisons pour lesquelles cela est susceptible de provoquer des problèmes :

- Les constructeurs pour les objets individuels dans le tableau sont appelés, mais les destructeurs ne sont pas appelés.

- Si l’opérateur global ou spécifique à la classe, **operator new** et **operator delete** ne sont pas compatibles avec **operator new []** et **operator delete []** , des résultats inattendus sont susceptibles de se produire.

- Il est toujours risqué de s’appuyer sur un comportement non défini.

Les ramifications exactes de ce défaut sont difficiles à prédire. Cela peut provoquer des fuites pour les classes avec des destructeurs qui effectuent la désallocation de mémoire ; comportement incohérent pour les classes avec des destructeurs qui effectuent une opération sémantiquement significative ; ou des altérations de la mémoire et des blocages quand les opérateurs ont été remplacés. Dans d’autres cas, l’incompatibilité peut être sans importance, en fonction de l’implémentation du compilateur et de ses bibliothèques. L’outil d’analyse ne peut pas toujours faire la distinction entre ces situations.

Si la mémoire est allouée avec **un tableau New []** , elle doit généralement être libérée avec la suppression de tableau **[]** .

## <a name="example"></a>Exemple

L’exemple de code suivant génère cet avertissement :

```cpp
class A
{
  // members
};

void f( )
{
  A *pA = new A[5];
  // code ...
  delete pA;
}
```

Pour corriger cet avertissement, utilisez l’exemple de code suivant :

```cpp
void f( )
{
  A *pA = new A[5];
  // code ...
  delete[] pA;
}
```

Si l’objet sous-jacent dans le tableau est un type primitif tel que `int`, `float`, `enum` ou un pointeur, aucun destructeur n’est appelé. Dans ce cas, l’avertissement [C6283](../code-quality/c6283.md) est signalé à la place.

L’utilisation des nouvelles et des suppressions présente de nombreux pièges en termes de fuites de mémoire et d’exceptions. Pour éviter l’ensemble de ces types de fuites et de problèmes d’exception, utilisez les mécanismes fournis par C++ la bibliothèque STL (Standard Template Library). Il s’agit notamment de [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)et [Vector](/cpp/standard-library/vector). Pour plus d’informations, consultez [pointeurs intelligents](/cpp/cpp/smart-pointers-modern-cpp) et [ C++ bibliothèque standard](/cpp/standard-library/cpp-standard-library-reference).
