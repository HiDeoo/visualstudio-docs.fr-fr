---
title: 'CA1062 : Valider les arguments de méthodes publiques'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
- Validate arguments of public methods
helpviewer_keywords:
- CA1062
- ValidateArgumentsOfPublicMethods
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 80e3d1d6a6c9db3912048aee9c282ec5f105a121
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/01/2020
ms.locfileid: "75580719"
---
# <a name="ca1062-validate-arguments-of-public-methods"></a>CA1062 : Valider les arguments de méthodes publiques

|||
|-|-|
|TypeName|ValidateArgumentsOfPublicMethods|
|CheckId|CA1062|
|Catégorie|Microsoft.Design|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une méthode visible de l’extérieur déréférence l’un de ses arguments de référence sans vérifier si cet argument est `null` (`Nothing` dans Visual Basic).

Les aspects suivants de cette règle sont [configurables](#configurability):
* Indique s’il faut ou non analyser le paramètre de la méthode d’extension’This'.
* Spécifiez les méthodes de validation de contrôle de valeur null dans les bibliothèques ou les projets référencés, qui valident que les arguments qui lui sont passés n’ont pas la valeur null.
* Parties de code base à exclure de l’analyse.

## <a name="rule-description"></a>Description de la règle

Tous les arguments de référence passés aux méthodes visibles de l’extérieur doivent être vérifiés par rapport à `null`. Le cas échéant, levez une <xref:System.ArgumentNullException> lorsque l’argument est `null`.

Si une méthode peut être appelée à partir d’un assembly inconnu, car elle est déclarée publique ou protégée, vous devez valider tous les paramètres de la méthode. Si la méthode est conçue pour être appelée uniquement par des assemblys connus, vous devez rendre la méthode interne et appliquer l’attribut <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> à l’assembly qui contient la méthode.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, validez chaque argument de référence par rapport `null`.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Vous pouvez supprimer un avertissement de cette règle si vous êtes sûr que le paramètre déréférencé a été validé par un autre appel de méthode dans la fonction.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir d' [analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), vous pouvez configurer l’analyse pour cette règle.

### <a name="exclude-extension-method-this-parameter"></a>Exclure le paramètre de la méthode d’extension’This'

Par défaut, cette règle analyse et signale le paramètre `this` pour les méthodes d’extension. Vous pouvez exclure l’analyse du paramètre `this` pour les méthodes d’extension en ajoutant la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA1062.exclude_extension_method_this_parameter = true
```

### <a name="null-check-validation-methods"></a>Méthodes de validation de contrôle de valeur null

Cette règle peut entraîner des faux positifs si votre code appelle des méthodes de validation de contrôle de valeur null spéciales dans des bibliothèques ou des projets référencés. Vous pouvez éviter ces faux positifs en spécifiant le nom ou la signature des méthodes de validation de vérification de la valeur null.  L’analyse suppose ensuite que les arguments passés à cette méthode sont non null après l’appel. Par exemple, pour marquer toutes les méthodes nommées `Validate` en tant que méthodes de validation de contrôle de valeur null, vous pouvez ajouter la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA1062.null_check_validation_methods = Validate
```

Formats de nom de méthode autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de la méthode uniquement (comprend toutes les méthodes portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole, avec un préfixe `M:` facultatif.

Exemples :

| Valeur d’option | Récapitulatif |
| --- | --- |
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate` | Correspond à toutes les méthodes nommées « Validate » dans la compilation
|`dotnet_code_quality.CA1062.null_check_validation_methods = Validate1|Validate2` | Correspond à toutes les méthodes nommées’Validate1 'ou’Validate2 'dans la compilation
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS.MyType.Validate(ParamType)` | Correspond à la méthode spécifique « Validate » avec la signature complète donnée
|`dotnet_code_quality.CA1062.null_check_validation_methods = NS1.MyType1.Validate1(ParamType)|NS2.MyType2.Validate2(ParamType)` | Met en correspondance des méthodes spécifiques « Validate1 » et « Validate2 » avec la signature complète respective

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType`, ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA1062.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
  - `.ctor` pour les constructeurs et les `.cctor` pour les constructeurs statiques

Exemples :

| Valeur d’option | Récapitulatif |
| --- | --- |
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA1062.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA1062.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (conception). Pour plus d’informations, consultez [configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Exemple

L’exemple suivant montre une méthode qui enfreint la règle et une méthode qui satisfait la règle.

```csharp
using System;

namespace DesignLibrary
{
    public class Test
    {
        // This method violates the rule.
        public void DoNotValidate(string input)
        {
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }

        // This method satisfies the rule.
        public void Validate(string input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            if (input.Length != 0)
            {
                Console.WriteLine(input);
            }
        }
    }
}
```

```vb
Imports System

Namespace DesignLibrary

    Public Class Test

        ' This method violates the rule.
        Sub DoNotValidate(ByVal input As String)

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

        ' This method satisfies the rule.
        Sub Validate(ByVal input As String)

            If input Is Nothing Then
                Throw New ArgumentNullException(NameOf(input))
            End If

            If input.Length <> 0 Then
                Console.WriteLine(input)
            End If

        End Sub

    End Class

End Namespace
```

## <a name="example"></a>Exemple

Les constructeurs de copie qui remplissent des champs ou des propriétés qui sont des objets de référence peuvent également enfreindre la règle CA1062. La violation se produit parce que l’objet copié qui est passé au constructeur de copie peut être `null` (`Nothing` dans Visual Basic). Pour résoudre la violation, utilisez une méthode statique (Shared in Visual Basic) pour vérifier que l’objet copié n’a pas la valeur null.

Dans l’exemple de classe `Person` suivant, l’objet `other` passé au constructeur de copie `Person` peut être `null`.

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor CA1062 fires because other is dereferenced
    // without being checked for null
    public Person(Person other)
        : this(other.Name, other.Age)
    {
    }
}
```

## <a name="example"></a>Exemple

Dans l’exemple de `Person` révisé suivant, l’objet `other` passé au constructeur de copie est d’abord vérifié pour la valeur null dans la méthode `PassThroughNonNull`.

```csharp
public class Person
{
    public string Name { get; private set; }
    public int Age { get; private set; }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Copy constructor
    public Person(Person other)
        : this(PassThroughNonNull(other).Name, other.Age)
    {
    }

    // Null check method
    private static Person PassThroughNonNull(Person person)
    {
        if (person == null)
            throw new ArgumentNullException(nameof(person));
        return person;
    }
}
```
