---
title: C26441
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 79b22325e747966e87f11268fd353d3ce8a94a36
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/02/2019
ms.locfileid: "53933124"
---
# <a name="c26441-nounnamedguards"></a>C26441 NO_UNNAMED_GUARDS
« Les objets de protection doivent être nommés ».

**C++ Core Guidelines**: CP.44 : N’oubliez pas de nommer votre lock_guards et l’unique_locks

La bibliothèque standard fournit quelques classes utiles qui permettent de contrôler l’accès simultané aux ressources. Objets de ces types de verrouiller l’accès exclusif pour la durée de leur durée de vie. Cela implique que chaque objet de verrouillage doit être nommé, c'est-à-dire ont eux-mêmes clairement défini de durée de vie qui s’étend à la période dans laquelle accèdent les opérations sont exécutées. Par conséquent, ne parvient pas à attribuer un objet verrou à une variable est une erreur qui est effectivement désactive le mécanisme de verrouillage (étant donné que les variables temporaires sont temporaires). Cette règle tente d’intercepter un cas simple d’un tel comportement inattendu.

## <a name="remarks"></a>Notes
- Seuls les types de verrouillage standard sont suivies : std::scoped_lock, std::unique_lock et std::lock_quard.
  - Uniquement de simples appels aux constructeurs sont analysés. Expression d’initialiseur plus complexe peut entraîner des résultats inexacts, mais il s’agit plutôt d’un scénario inhabituel.
  - Verrouille passées comme arguments aux appels de fonction ou retourné les résultats de la fonction, les appels sont ignorés.
  - Verrous créé en tant qu’objets temporaires mais affecté aux références nommées pour étendre leur durée de vie sont ignorés.
    ## <a name="example"></a>Exemple
    étendue de la variable manquant

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

## <a name="example"></a>Exemple
manquant portée variable - corrigé

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
