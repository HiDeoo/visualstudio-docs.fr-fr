---
title: 'CA2100 : Vérifier si les requêtes SQL présentent des failles de sécurité'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Review SQL queries for security vulnerabilities
- ReviewSqlQueriesForSecurityVulnerabilities
- CA2100
helpviewer_keywords:
- CA2100
- ReviewSqlQueriesForSecurityVulnerabilities
ms.assetid: 79670604-c02a-448d-9c0e-7ea0120bc5fe
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: e7574fa1826e5b9add96f0851be48429551506dd
ms.sourcegitcommit: a18c7e9b367c2f92f6e54c3eaef442775d457667
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90098735"
---
# <a name="ca2100-review-sql-queries-for-security-vulnerabilities"></a>CA2100 : Vérifier si les requêtes SQL présentent des failles de sécurité

|Élément|Valeur|
|-|-|
|ID de la règle|CA2100|
|Category|Microsoft.Security|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Une méthode définit la <xref:System.Data.IDbCommand.CommandText%2A?displayProperty=fullName> propriété à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode.

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

## <a name="rule-description"></a>Description de la règle

Cette règle suppose que toute chaîne, dont la valeur ne peut pas être déterminée au moment de la compilation, peut contenir une entrée d’utilisateur. Une chaîne de commande SQL générée par une entrée d'utilisateur est vulnérable aux attaques par injection de code SQL. Dans une attaque par injection SQL, un utilisateur malveillant fournit des entrées qui modifient la conception d’une requête en tentant d’endommager ou d’obtenir un accès non autorisé à la base de données sous-jacente. Les techniques classiques incluent l’injection d’un guillemet simple ou d’une apostrophe, qui est le délimiteur de chaîne littérale SQL ; deux tirets, ce qui signifie un commentaire SQL ; et un point-virgule, qui indique qu’une nouvelle commande suit. Si l’entrée utilisateur doit faire partie de la requête, utilisez l’un des éléments suivants, par ordre d’efficacité, pour réduire le risque d’attaque.

- Utilisez une procédure stockée.

- Utilisez une chaîne de commande paramétrable.

- Validez l’entrée utilisateur pour le type et le contenu avant de générer la chaîne de commande.

Les types .NET suivants implémentent la <xref:System.Data.IDbCommand.CommandText%2A> propriété ou fournissent des constructeurs qui définissent la propriété à l’aide d’un argument de chaîne.

- <xref:System.Data.Odbc.OdbcCommand?displayProperty=fullName> et <xref:System.Data.Odbc.OdbcDataAdapter?displayProperty=fullName>

- <xref:System.Data.OleDb.OleDbCommand?displayProperty=fullName> et <xref:System.Data.OleDb.OleDbDataAdapter?displayProperty=fullName>

- <xref:System.Data.OracleClient.OracleCommand?displayProperty=fullName> et <xref:System.Data.OracleClient.OracleDataAdapter?displayProperty=fullName>

- <xref:System.Data.SqlClient.SqlCommand?displayProperty=fullName> et <xref:System.Data.SqlClient.SqlDataAdapter?displayProperty=fullName>

Dans certains cas, cette règle peut ne pas déterminer la valeur d’une chaîne au moment de la compilation, même si vous le pouvez. Dans ce cas, cette règle génère des faux positifs lors de l’utilisation de ces chaînes en tant que commandes SQL. Voici un exemple d’une telle chaîne.

```csharp
int x = 10;
string query = "SELECT TOP " + x.ToString() + " FROM Table";
```

Il en va de même lorsque vous utilisez `ToString()` implicitement.

```csharp
int x = 10;
string query = String.Format("SELECT TOP {0} FROM Table", x);
```

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, utilisez une requête paramétrable.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Il est possible de supprimer sans risque un avertissement de cette règle si le texte de la commande ne contient aucune entrée d’utilisateur.

## <a name="configurability"></a>Configurabilité

Cette règle comporte les options configurables suivantes.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType` , ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA2100.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
- Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
- Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
- `.ctor` pour les constructeurs et `.cctor` les constructeurs statiques

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA2100.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA2100.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA2100.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA2100.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (sécurité). Pour plus d’informations, consultez [configurer des analyseurs de qualité du code .net](configure-fxcop-analyzers.md).

## <a name="example"></a> Exemple

L’exemple suivant montre une méthode, `UnsafeQuery` , qui enfreint la règle et une méthode, `SaferQuery` , qui satisfait la règle à l’aide d’une chaîne de commande paramétrable.

[!code-vb[FxCop.Security.ReviewSqlQueries#1](../code-quality/codesnippet/VisualBasic/ca2100-review-sql-queries-for-security-vulnerabilities_1.vb)]
[!code-csharp[FxCop.Security.ReviewSqlQueries#1](../code-quality/codesnippet/CSharp/ca2100-review-sql-queries-for-security-vulnerabilities_1.cs)]

## <a name="see-also"></a>Voir aussi

- [Présentation de la sécurité](/dotnet/framework/data/adonet/security-overview)
