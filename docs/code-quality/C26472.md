---
title: C26472
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26472
helpviewer_keywords:
- C26472
ms.assetid: 51e215a7-0e0a-4e6c-bff1-805bf5b1af29
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 4badf8ae66864ac4e425ed03369fb4ebbdefb709
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/02/2019
ms.locfileid: "53849106"
---
# <a name="c26472-nocastsforarithmeticconversion"></a>C26472 NO_CASTS_FOR_ARITHMETIC_CONVERSION
« N’utilisez pas static_cast pour les conversions arithmétiques. Utilisez les accolades, gsl::narrow_cast ou gsl::narrow ».

**C++ Core Guidelines**: Type.1 : Évitez des conversions

Cette règle vous aide à trouver des endroits où les casts statiques sont utilisées pour effectuer des conversions entre types intégraux, qui n’est pas sûre, car le compilateur n’aurait pas avertir en cas de perte de données. Initialiseurs d’accolade conviennent mieux pour les cas où les constantes sont utilisées, et une erreur de compilation est souhaitée. Il existe également des utilitaires à partir de la bibliothèque de prise en charge les instructions permettant de décrire clairement les intentions :
-   GSL::Narrow garantit la conversion sans perte et provoque le blocage de l’exécution s’il n’est pas possible.
-   GSL::narrow_cast indique clairement que la conversion peut perdre des données et il est acceptable.

## <a name="remarks"></a>Notes
- Cette règle est implémentée uniquement pour static_casts. À l’aide de casts de style C est généralement déconseillée.
  ## <a name="example"></a>Exemple
  données inattendues non prise en charge

```cpp
rgb from_24bit(std::uint32_t v) noexcept {
    return {
        static_cast<std::uint8_t>(v >> 16),         // C26472, what if top byte is non-zero?
        static_cast<std::uint8_t>((v >> 8) & 0xFF), // C26472
        static_cast<std::uint8_t>(v & 0xFF)         // C26472
    };
}
```

## <a name="example"></a>Exemple
données inattendues non prise en charge – version plus sûre

```cpp
rgb from_24bit(std::uint32_t v) noexcept {
    return {
        gsl::narrow<std::uint8_t>(v >> 16),
        gsl::narrow_cast<std::uint8_t>((v >> 8) & 0xFF),
        gsl::narrow_cast<std::uint8_t>(v & 0xFF)
    };
}
```
