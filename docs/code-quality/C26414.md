---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011679"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

« Déplacer, copier, réassigner ou réinitialiser un pointeur intelligent local. »

**C++ Instructions principales**: R. 5 : Préférer les objets délimités, pas de tas-Allocate inutilement

Les pointeurs intelligents sont pratiques pour la gestion dynamique des ressources, mais ils ne sont pas toujours nécessaires. Par exemple, la création d’un tampon dynamique local peut être facilement (fin parfois plus efficace) gérée par des conteneurs standard. Pour les objets uniques, il peut être inutile d’effectuer des allocations dynamiques (par exemple, si ces objets ne vivent jamais à leur fonction Creator) et qu’ils peuvent être remplacés par des variables locales. Les pointeurs intelligents deviennent pratiques lorsque le scénario nécessite le changement de propriété, c’est-à-dire la réassignation d’une ressource dynamique plusieurs fois ou dans plusieurs chemins. Cela comprend également les cas où les ressources sont obtenues à partir du code externe et les pointeurs intelligents sont utilisés pour étendre la durée de vie de la ressource.

## <a name="remarks"></a>Notes

- Outre les modèles std :: unique_pointer et std :: shared_pointer standard, cette vérification reconnaît les types définis par l’utilisateur qui sont susceptibles d’être des pointeurs intelligents. Ces types sont censés définir les opérations suivantes :
  - déréférencement surchargé ou opérateurs d’accès aux membres, qui sont publics et non marqués comme supprimés ;
  - destructeur public qui n’est ni supprimé ni par défaut. Cela comprend les destructeurs qui sont définis explicitement comme vides.
  - Le type Microsoft :: WRL :: ComPtr se comporte comme un pointeur partagé, mais il est souvent utilisé dans des scénarios très spécifiques qui sont affectés par la gestion de la durée de vie COM. Pour éviter un bruit excessif, ce type est filtré.
  - Cette vérification recherche les allocations locales explicites affectées aux pointeurs intelligents pour déterminer si les variables délimitées peuvent être des mots comme alternative. En plus des appels directs à operator new, les fonctions spéciales telles que STD :: make_unique et std :: make_shared sont également interprétées comme des allocations directes.

## <a name="example"></a>Exemple

mémoire tampon dynamique

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

mémoire tampon dynamique – remplacée par le conteneur

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
