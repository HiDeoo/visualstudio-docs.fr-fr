---
title: Avertissements liés au design
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design warnings
- managed code analysis warnings, design warnings
- warnings, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 59f9a5ed6a7e9bab7031009d66bacf56a878fe41
ms.sourcegitcommit: 5caad925ca0b5d136416144a279e984836d8f28c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/07/2020
ms.locfileid: "89508559"
---
# <a name="design-warnings"></a>Avertissements liés à la conception

Les avertissements de conception prennent en charge l’adhésion aux [règles de conception de .NET Framework](/dotnet/standard/design-guidelines/).

## <a name="in-this-section"></a>Dans cette section

| Règle | Description |
| - | - |
| [CA1000 : Ne pas déclarer de membres statiques sur les types génériques](../code-quality/ca1000.md) | Lorsqu'un membre statique d'un type générique est appelé, l'argument de type doit être spécifié pour le type. Lorsqu'un membre d'instance générique qui ne prend pas en charge l'inférence est appelé, l'argument de type doit être spécifié pour le membre. Dans ces deux cas, la syntaxe permettant de spécifier l'argument de type est différente et peut être facilement confondue. |
| [CA1001 : Les types qui possèdent des champs supprimables doivent être supprimables](../code-quality/ca1001.md) | Une classe déclare et implémente un champ d’instance qui est un type System. IDisposable et la classe n’implémente pas IDisposable. Une classe qui déclare un champ IDisposable possède indirectement une ressource non managée et doit implémenter l'interface IDisposable. |
| [CA1002 : Ne pas exposer de listes génériques](../code-quality/ca1002.md) | System. Collections. Generic. List< (of \<(T> ) >) est une collection générique conçue pour les performances, et non pour l’héritage. Par conséquent, la liste ne contient aucun membre virtuel. Les collections génériques qui sont conçues pour l’héritage doivent être exposées à la place. |
| [CA1003 : Utiliser les instances du gestionnaire d'événements génériques](../code-quality/ca1003.md) | Un type contient un délégué qui retourne void, dont la signature contient deux paramètres (le premier objet et le deuxième un type qui peut être assigné à EventArgs), et l’assembly conteneur cible .NET Framework 2,0. |
| [CA1005 : Éviter les paramètres excessifs sur les types génériques](../code-quality/ca1005.md) | Plus un type générique contient de paramètres de type, plus il est difficile de déterminer et de mémoriser la représentation de chaque paramètre de type. Elle est généralement évidente avec un paramètre de type, comme dans la liste \<T> , et dans certains cas avec deux paramètres de type, comme dans Dictionary \<TKey, TValue> . Cependant, s’il existe plus de deux paramètres de type, la difficulté devient trop grande pour la plupart des utilisateurs. |
| [CA1008 : Les enums doivent avoir la valeur zéro](../code-quality/ca1008.md) | La valeur par défaut d'une énumération non initialisée, comme d'autres types valeur, est zéro. Une énumération attribuée sans indicateur doit définir un membre à l’aide de la valeur de zéro afin que la valeur par défaut soit une valeur valide de l’énumération. Si une énumération à laquelle l'attribut FlagsAttribute est appliqué définit un membre de valeur zéro, son nom doit être "None" pour indiquer qu'aucune valeur n'a été définie dans l'énumération. |
| [CA1010 : Les collections doivent implémenter une interface générique](../code-quality/ca1010.md) | Pour étendre la facilité d’utilisation d’une collection, implémentez l’une des interfaces de collection génériques. La collection peut être ensuite utilisée pour remplir des types de collection génériques. |
| [CA1012 : Les types abstract ne doivent pas avoir de constructeurs](../code-quality/ca1012.md) | Les constructeurs des types abstraits peuvent être appelés uniquement par des types dérivés. Étant donné que les constructeurs publics créent des instances d'un type et que vous ne pouvez pas créer d'instance d'un type abstrait, un type abstrait doté d'un constructeur public est de conception incorrecte. |
| [CA1014 : Marquer les assemblys avec CLSCompliantAttribute](../code-quality/ca1014.md) | La spécification de langage commun CLS (Common Language Specification) définit des restrictions de dénomination, des types de données, et des règles auxquelles les assemblys doivent se conformer s'ils doivent être utilisés à l'échelle de différents langages de programmation. Une bonne conception impose que tous les assemblys indiquent explicitement la conformité CLS à l’aide de CLSCompliantAttribute. Si cet attribut n'est pas présent sur un assembly, l'assembly n'est pas conforme. |
| [CA1016 : Marquer les assemblys avec AssemblyVersionAttribute](../code-quality/ca1016.md) | .NET utilise le numéro de version pour identifier de manière unique un assembly et pour établir une liaison aux types dans des assemblys avec nom fort. Le numéro de version est utilisé conjointement avec la version et la stratégie d'éditeur. Par défaut, les applications s'exécutent uniquement avec la version d'assembly avec laquelle elles ont été construites. |
| [CA1017 : Marquer les assemblys avec ComVisibleAttribute](../code-quality/ca1017.md) | ComVisibleAttribute détermine comment les clients COM accèdent à du code managé. Un bon design stipule que les assemblys indiquent explicitement la visibilité COM. La visibilité COM peut être définie pour l'assembly en entier, puis être substituée pour des types et des membres de type individuels. Si cet attribut n'est pas présent, les clients COM peuvent voir le contenu de l'assembly. |
| [CA1018 : Marquer les attributs avec AttributeUsageAttribute](../code-quality/ca1018.md) | Lorsque vous définissez un attribut personnalisé, marquez-le à l'aide d'AttributeUsageAttribute pour indiquer où l'attribut personnalisé peut être appliqué dans le code source. La signification et l'utilisation prévue d'un attribut déterminent ses emplacements valides au sein d'un code. |
| [CA1019 : Définir des accesseurs pour les arguments d'attribut](../code-quality/ca1019.md) | Les attributs peuvent définir des arguments obligatoires qui doivent être spécifiés lorsque vous appliquez l’attribut à une cible. Ceux-ci sont également appelés arguments positionnels parce qu’ils sont fournis aux constructeurs d’attributs en tant que paramètres positionnels. Pour chaque argument obligatoire, l'attribut doit également fournir une propriété en lecture seule correspondante afin que la valeur de l'argument puisse être récupérée au moment de l'exécution. Les attributs peuvent également définir des arguments facultatifs, qui sont également appelés arguments nommés. Ces arguments sont fournis aux constructeurs d’attributs par noms et doivent disposer d’une propriété en lecture/écriture correspondante. |
| [CA1021 : Éviter les paramètres out](../code-quality/ca1021.md) | Passer des types par référence (en utilisant out ou ref) nécessite une certaine expérience des pointeurs, de comprendre la différence entre les types valeur et les types référence, ainsi que la gestion de méthodes impliquant plusieurs valeurs de retour. Par ailleurs, la différence entre les paramètres out et ref est généralement peu comprise. |
| [CA1024 : Utiliser les propriétés lorsque cela est approprié](../code-quality/ca1024.md) | Le nom d'une méthode publique ou protégée commence par « Get », n'accepte aucun paramètre et retourne une valeur qui n'est pas un tableau. La méthode est susceptible de devenir une propriété. |
| [CA1027 : Marquer les enums avec FlagsAttribute](../code-quality/ca1027.md) | Une énumération est un type valeur qui définit un jeu de constantes nommées associées. Appliquez FlagsAttribute à une énumération lorsque ses constantes nommées peuvent être combinées de manière pertinente. |
| [CA1028 : Enum Storage doit être Int32](../code-quality/ca1028.md) | Une énumération est un type valeur qui définit un jeu de constantes nommées associées. Par défaut, le type de données System.Int32 est utilisé pour stocker la valeur de constante. Même si vous pouvez modifier ce type sous-jacent, il n’est pas obligatoire ou recommandé pour la plupart des scénarios. |
| [CA1030 : Utiliser des événements lorsque cela est approprié](../code-quality/ca1030.md) | Cette règle détecte des méthodes qui présentent des noms qui ordinairement seraient utilisés pour des événements. Si une méthode est appelée en réponse à une modification d'état clairement définie, la méthode doit être appelée par un gestionnaire d'événements. Les objets qui appellent la méthode doivent déclencher des événements au lieu d'appeler directement la méthode. |
| [CA1031 : Ne pas intercepter des types d'exception générale](../code-quality/ca1031.md) | Les exceptions générales ne doivent pas être interceptées. Interceptez une exception plus spécifique ou levez à nouveau l’exception générale comme dernière instruction dans le bloc catch. |
| [CA1032 : Implémenter des constructeurs d'exception standard](../code-quality/ca1032.md) | Ne pas fournir le jeu complet de constructeurs peut rendre difficile une gestion des exceptions correcte. |
| [CA1033 : Les méthodes d'interface doivent pouvoir être appelées par les types enfants](../code-quality/ca1033.md) | Un type unsealed visible de l'extérieur fournit une implémentation de méthode explicite d'une interface publique mais ne fournit aucune méthode de substitution visible de l'extérieur de même nom. |
| [CA1034 : Les types imbriqués ne doivent pas être visibles](../code-quality/ca1034.md) | Un type imbriqué représente un type déclaré dans la portée d'un autre type. Les types imbriqués sont utiles pour encapsuler les détails de l'implémentation privée du type conteneur. Utilisés à cette fin, les types imbriqués ne doivent pas être visibles de l'extérieur. |
| [CA1036 : Substituer les méthodes sur les types Comparable](../code-quality/ca1036.md) | Un type public ou protégé implémente l'interface System.IComparable. Il ne substitue pas Object.Equals, ni ne surcharge l'opérateur égal à, différent de, inférieur à ou supérieur à propre au langage. |
| [CA1040 : Éviter les interfaces vides](../code-quality/ca1040.md) | Les interfaces définissent des membres qui fournissent un comportement ou un contrat d'utilisation. Les fonctionnalités décrites par l'interface peuvent être adoptées par tout type, indépendamment de l'endroit où le type figure dans la hiérarchie d'héritage. Un type implémente une interface en fournissant des implémentations pour les membres de celle-ci. Une interface vide ne définit aucun membre ; par conséquent, elle ne définit aucun contrat pouvant être implémenté. |
| [CA1041 : Fournir un message ObsoleteAttribute](../code-quality/ca1041.md) | Un type ou un membre est marqué avec un attribut System.ObsoleteAttribute dont la propriété ObsoleteAttribute.Message n'est pas spécifiée. Lorsqu’un type ou un membre qui est marqué à l’aide de ObsoleteAttribute est compilé, la propriété message de l’attribut s’affiche, qui donne à l’utilisateur des informations sur le type ou le membre obsolète. |
| [CA1043 : Utiliser un argument de chaîne ou intégral pour les indexeurs](../code-quality/ca1043.md) | Les indexeurs (c'est-à-dire les propriétés indexées) doivent utiliser des types intégral ou chaîne pour l'index. Ces types sont généralement utilisés pour indexer des structures de données et augmentent la facilité d'utilisation de la bibliothèque. L'utilisation du type Object doit se restreindre aux cas où le type intégral ou de chaîne spécifique ne peut pas être spécifié au moment du design. |
| [CA1044 : Les propriétés ne doivent pas être en écriture seule](../code-quality/ca1044.md) | Bien qu'il soit acceptable et souvent nécessaire de disposer d'une propriété en lecture seule, les règles de conception interdisent l'utilisation de propriétés en écriture seule. Le fait de permettre à un utilisateur de définir une valeur et l'empêcher ensuite de la consulter n'offre aucune garantie de sécurité. De plus, sans accès en lecture, l'état des objets partagés ne peut s'afficher, ce qui limite leur utilité. |
| [CA1045 : Ne pas passer de types par référence](../code-quality/ca1045.md) | Passer des types par référence (en utilisant out ou ref) nécessite une certaine expérience des pointeurs, de comprendre la différence entre les types valeur et les types référence, ainsi que la gestion de méthodes impliquant plusieurs valeurs de retour. Les architectes de bibliothèques qui réalisent un travail de conception destiné à une audience générale ne doivent pas s'attendre à ce que les utilisateurs maîtrisent l'utilisation des paramètres out ou ref. |
| [CA1046 : Ne pas surcharger l'opérateur égal à sur les types référence](../code-quality/ca1046.md) | Pour les types référence, l'implémentation par défaut de l'opérateur d'égalité est presque toujours correcte. Par défaut, deux références sont égales uniquement si elles pointent sur le même objet. |
| [CA1047 : Ne pas déclarer les membres protégés dans les types sealed](../code-quality/ca1047.md) | Les types déclarent des membres protégés afin que des types qui héritent puissent accéder au membre ou le substituer. Par définition, les types sealed ne peuvent pas être hérités, ce qui signifie que les méthodes protégées sur les types sealed ne peuvent pas être appelées. |
| [CA1050 : Déclarer les types dans des espaces de noms](../code-quality/ca1050.md) | Les types sont déclarés au sein d'espaces de noms pour empêcher des collisions de dénomination, ainsi qu'en guise que méthode d'organisation de types connexes au sein d'une hiérarchie d'objets. |
| [CA1051 : Ne pas déclarer de champs d'instances visibles](../code-quality/ca1051.md) | Un champ s'utilise principalement en tant que détail d'implémentation. Les champs doivent être privés ou internes, et doivent être exposés au moyen de propriétés. |
| [CA1052 : Les types de conteneurs statiques doivent être sealed](../code-quality/ca1052.md) | Un type public ou protégé contient uniquement des membres statiques et n’est pas déclaré à l’aide du modificateur sealed (C#) ou NotInheritable (Visual Basic). Un type qui n'est pas destiné à être hérité doit être marqué avec le modificateur sealed pour empêcher son utilisation en tant que type de base. |
| [CA1053 : Les types de conteneurs statiques ne doivent pas comporter de constructeur](../code-quality/ca1053.md) | Un type public ou imbriqué déclare uniquement des membres statiques et dispose d'un constructeur par défaut public ou protégé. Le constructeur est inutile car l'appel à des membres statiques ne requiert aucune instance du type. La surcharge de chaîne doit appeler la surcharge d'URI (Uniform Resource Identifier) à l'aide de l'argument de chaîne pour des raisons de sécurité. |
| [CA1054 : Les paramètres URI ne doivent pas être des chaînes](../code-quality/ca1054.md) | Si une méthode accepte une représentation sous forme de chaîne d'un URI, une surcharge correspondante qui accepte une instance de la classe URI doit être fournie ; elle-même fournit ces services de manière sûre et sécurisée. |
| [CA1055 : Les valeurs de retour URI ne doivent pas être des chaînes](../code-quality/ca1055.md) | Cette règle considère que la méthode retourne un URI. Une représentation sous forme de chaîne d'un URI est sujette aux erreurs d'analyse et d'encodage, et peut entraîner des failles de sécurité. La classe System.Uri fournit ces services de manière sûre et sécurisée. |
| [CA1056 : Les propriétés URI ne doivent pas être des chaînes](../code-quality/ca1056.md) | Cette règle suppose que la propriété représente un URI. Une représentation sous forme de chaîne d'un URI est sujette aux erreurs d'analyse et d'encodage, et peut entraîner des failles de sécurité. La classe System.Uri fournit ces services de manière sûre et sécurisée. |
| [CA1058 : Les types ne doivent pas étendre certains types de base](../code-quality/ca1058.md) | Un type visible de l'extérieur étend certains types de base. Utilisez l'une des solutions de remplacement. |
| [CA1060 : déplacer les P/Invoke vers une classe NativeMethods](../code-quality/ca1060.md) | Les méthodes d’appel de plateforme, telles que celles marquées avec les <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> méthodes ou définies à l’aide du mot clé Declare dans [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] , accèdent au code non managé. Ces méthodes doivent être de la classe NativeMethods, SafeNativeMethods ou UnsafeNativeMethods. |
| [CA1061 : Ne pas masquer les méthodes de la classe de base](../code-quality/ca1061.md) | Une méthode dans un type de base est masquée par une méthode portant le même nom dans un type dérivé, lorsque la signature de paramètre de la méthode dérivée diffère uniquement par les types qui sont dérivés plus faiblement que les types correspondants dans la signature de paramètre de la méthode de base. |
| [CA1062 : Valider les arguments de méthodes publiques](../code-quality/ca1062.md) | Tous les arguments de référence passés aux méthodes visibles de l'extérieur doivent être vérifiés pour voir s'ils ont la valeur null. |
| [CA1063 : Implémenter IDisposable correctement](../code-quality/ca1063.md) | Tous les types IDisposable doivent implémenter le modèle Dispose correctement. |
| [CA1064 : Les exceptions doivent être publiques](../code-quality/ca1064.md) | Une exception interne est uniquement visible à l'intérieur de sa propre portée interne. Lorsque l'exception se situe en dehors de la portée interne, seule l'exception de base peut être utilisée pour intercepter l'exception. Si l’exception interne est héritée de <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> ou <xref:System.ApplicationException?displayProperty=fullName> , le code externe ne disposera pas d’informations suffisantes pour savoir ce qu’il faut faire avec l’exception. |
| [CA1065 : Ne pas lever d'exceptions dans les emplacements inattendus](../code-quality/ca1065.md) | Une méthode dont l'objet n'est pas de lever des exceptions lève une exception. |
| [CA1066 : Implémenter IEquatable au moment de remplacer Equals](../code-quality/ca1066.md) | Un type valeur substitue la <xref:System.Object.Equals%2A> méthode, mais n’implémente pas <xref:System.IEquatable%601> . |
| [CA1067: Remplacer Equals lors de l’implémentation d’IEquatable](../code-quality/ca1067.md) | Un type implémente <xref:System.IEquatable%601> , mais ne se substitue pas à la <xref:System.Object.Equals%2A> méthode. |
| [CA1068 : Les paramètres CancellationToken doivent venir en dernier](../code-quality/ca1068.md) | Une méthode a un paramètre CancellationToken qui n’est pas le dernier paramètre. |
| [CA1069 : Les enums ne doivent pas avoir de valeurs en double](../code-quality/ca1069.md) | Une énumération a plusieurs membres auxquels la même valeur de constante est affectée explicitement. |
| [CA1070 : Ne pas déclarer de champs d’événement comme virtuels](../code-quality/ca1070.md) | Un [événement de type champ](/dotnet/csharp/language-reference/language-specification/classes#field-like-events) a été déclaré comme étant virtuel. |
