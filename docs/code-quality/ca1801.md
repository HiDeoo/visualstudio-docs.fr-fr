---
title: 'CA1801 : Passez en revue les paramètres inutilisés'
ms.date: 06/24/2019
ms.topic: reference
f1_keywords:
- AvoidUnusedParameters
- CA1801
- ReviewUnusedParameters
helpviewer_keywords:
- CA1801
- ReviewUnusedParameters
ms.assetid: 5d73545c-e153-4b7c-a7b2-be6bf5aca5be
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: b30f0cf5c9582f362666e4eff33c09953309d4c5
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/21/2020
ms.locfileid: "81648448"
---
# <a name="ca1801-review-unused-parameters"></a>CA1801 : Passez en revue les paramètres inutilisés

|||
|-|-|
|TypeName|ReviewUnusedParameters|
|CheckId|CA1801|
|Category|Microsoft.Utilisation|
|Modification avec rupture|Non-rupture - Si le membre n’est pas visible en dehors de l’assemblée, quel que soit le changement que vous effectuez.<br /><br /> Non-rupture - Si vous changez le membre pour utiliser le paramètre dans son corps.<br /><br /> Rupture - Si vous supprimez le paramètre et il est visible à l’extérieur de l’assemblage.|

## <a name="cause"></a>Cause

Une signature de méthode inclut un paramètre qui n’est pas utilisé dans le corps de la méthode.

Cette règle n’examine pas les types de méthodes suivants :

- Méthodes référencées par un délégué.

- Méthodes utilisées comme gestionnaires d’événements.

- Constructeurs de sérialisation[(voir les lignes directrices](/dotnet/standard/serialization/serialization-guidelines#supporting-runtime-serialization)).

- Méthode <xref:System.Runtime.Serialization.ISerializable.GetObjectData> de sérialisation.

- Méthodes déclarées `abstract` `MustOverride` avec le modificateur (dans Visual Basic).

- Méthodes déclarées `virtual` `Overridable` avec le modificateur (dans Visual Basic).

- Méthodes déclarées `override` `Overrides` avec le modificateur (dans Visual Basic).

- Méthodes déclarées `extern` `Declare` avec le modificateur (déclaration dans Visual Basic).

Si vous utilisez [des analyseurs FxCop](install-fxcop-analyzers.md), cette règle ne signale pas les `_` `_1`paramètres `_2`qui sont nommés avec le symbole [de rejet,](/dotnet/csharp/discards) par exemple, , , et . Cela réduit le bruit d’avertissement sur les paramètres qui sont nécessaires pour les exigences de signature, par exemple, une méthode utilisée comme un délégué, un paramètre avec des attributs spéciaux, ou un paramètre dont la valeur est implicitement accessible au moment de l’exécution par un cadre, mais n’est pas référencé dans le code.

## <a name="rule-description"></a>Description de la règle

Examinez les paramètres des méthodes non virtuelles qui ne sont pas utilisées dans le corps de la méthode pour s’assurer qu’il n’existe aucune inexactitude en ce qui a non-accédé. Les paramètres inutilisés entraînent des coûts d’entretien et de performance.

Parfois, une violation de cette règle peut indiquer un bogue de mise en œuvre dans la méthode. Par exemple, le paramètre aurait dû être utilisé dans le corps de la méthode. Supprimer les avertissements de cette règle si le paramètre doit exister en raison de la compatibilité vers l’arrière.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de cette règle, supprimez le paramètre inutilisé (un changement de rupture), ou utilisez le paramètre dans le corps de la méthode (un changement non-rupture).

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Il est sûr de supprimer un avertissement de cette règle:

- Dans le code précédemment expédié pour lequel le correctif serait un changement de rupture.

- Pour `this` le paramètre dans <xref:Microsoft.VisualStudio.TestTools.UnitTesting.Assert?displayProperty=nameWithType>une méthode d’extension personnalisée pour . Les fonctions <xref:Microsoft.VisualStudio.TestTools.UnitTesting.Assert> dans la classe sont statiques, il `this` n’y a donc pas besoin d’accéder au paramètre dans le corps de la méthode.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir [d’analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), vous pouvez configurer les parties de votre base de code pour exécuter cette règle, en fonction de leur accessibilité. Par exemple, pour spécifier que la règle ne doit s’exécuter que par rapport à la surface non publique de l’API, ajoutez la paire de valeur clé suivante à un fichier .editorconfig dans votre projet :

```ini
dotnet_code_quality.ca1801.api_surface = private, internal
```

Vous pouvez configurer cette option pour cette seule règle, pour toutes les règles, ou pour toutes les règles de cette catégorie (Performance). Pour plus d’informations, voir [Configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Exemple

L’exemple suivant montre deux méthodes. Une méthode viole la règle et l’autre méthode satisfait la règle.

[!code-csharp[FxCop.Usage.ReviewUnusedParameters#1](../code-quality/codesnippet/CSharp/ca1801-review-unused-parameters_1.cs)]

## <a name="related-rules"></a>Règles connexes

[CA1811 : Évitez le recours à du code privé non appelé](../code-quality/ca1811.md)

[CA1812 : Évitez les classes internes non instanciées](../code-quality/ca1812.md)

[CA1804 : Supprimez les variables locales inutilisées](../code-quality/ca1804.md)

[CA2229 : Implémentez des constructeurs de sérialisation](../code-quality/ca2229.md)
