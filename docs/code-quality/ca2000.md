---
title: "CA2000 : Supprimez les objets avant d'être hors de portée"
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615571"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000 : Supprimez les objets avant d'être hors de portée

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Category|Microsoft.Reliability (en)|
|Modification avec rupture|Non-rupture|

## <a name="cause"></a>Cause

Un objet local <xref:System.IDisposable> d’un type est créé, mais l’objet n’est pas éliminé avant que toutes les références à l’objet ne soient hors de portée.

Par défaut, cette règle analyse toute la base de code, mais [c’est configurable](#configurability).

## <a name="rule-description"></a>Description de la règle

Si un objet jetable n’est pas explicitement éliminé avant que toutes les références à celui-ci ne soient hors de portée, l’objet sera éliminé à un moment indéterminé lorsque le collecteur d’ordures exécute le finalisateur de l’objet. Étant donné qu’un événement exceptionnel peut se produire qui empêchera le finalisateur de l’objet de s’exécuter, l’objet doit être explicitement éliminé à la place.

### <a name="special-cases"></a>Cas particuliers

Règle CA2000 ne tire pas pour les objets locaux des types suivants, même si l’objet n’est pas éliminé:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Le fait de transmettre un objet de l’un de ces types à un constructeur, puis de l’attribuer à un champ indique un *transfert de propriété d’élimination* au type nouvellement construit. Autrement dit, le type nouvellement construit est maintenant responsable de l’élimination de l’objet. Si votre code transmet un objet de l’un de ces types à un constructeur, aucune violation de la règle CA2000 ne se produit même si l’objet n’est pas éliminé avant que toutes les références à celui-ci sont hors de portée.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

Pour corriger une violation de <xref:System.IDisposable.Dispose%2A> cette règle, faites appel à l’objet avant que toutes les références à celui-ci ne soient hors de portée.

Vous pouvez utiliser[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) <xref:System.IDisposable> [ `using` l’instruction](/dotnet/csharp/language-reference/keywords/using-statement) (dans Visual Basic) pour envelopper les objets qui implémentent . Les objets qui sont enveloppés de cette manière `using` sont automatiquement éliminés à la fin du bloc. Toutefois, les situations suivantes ne doivent pas `using` ou ne peuvent pas être traitées avec une déclaration :

- Pour retourner un objet jetable, `try/finally` l’objet `using` doit être construit dans un bloc à l’extérieur d’un bloc.

- N’initialisez pas les membres d’un `using` objet jetable dans le constructeur d’une déclaration.

- Lorsque les constructeurs qui sont protégés par un seul gestionnaire d’exception sont imbriqués dans la [partie d’acquisition `using` d’une déclaration](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement), une défaillance dans le constructeur extérieur peut entraîner l’objet créé par le constructeur imbriqué n’est jamais fermé. Dans l’exemple suivant, <xref:System.IO.StreamReader> une défaillance du <xref:System.IO.FileStream> constructeur peut entraîner la fermeture de l’objet. CA2000 signale une violation de la règle en l’espèce.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Les objets dynamiques doivent utiliser un <xref:System.IDisposable> objet d’ombre pour implémenter le modèle d’élimination des objets.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Ne supprimez pas un avertissement de cette règle à moins que :

- Vous avez appelé une méthode sur `Dispose`votre objet qui appelle , tels que<xref:System.IO.Stream.Close%2A>
- La méthode qui a <xref:System.IDisposable> soulevé l’avertissement renvoie un objet qui enveloppe votre objet
- La méthode d’attribution n’a pas la propriété d’élimination; c’est-à-dire que la responsabilité de disposer de l’objet est transférée à un autre objet ou emballage qui est créé dans la méthode et retourné à l’appelant

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir [d’analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse de l’héritage), vous pouvez configurer l’analyse pour cette règle.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre base de code à exclure de l’analyse. Par exemple, pour spécifier que la règle `MyType`ne doit pas s’exécuter sur n’importe quel code dans les types nommés, ajoutez la paire de valeur clé suivante à un fichier .editorconfig dans votre projet :

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Formats de nom de symbole autorisés dans la valeur d’option (séparés par '') :
  - Nom du symbole seulement (inclut tous les symboles avec le nom, indépendamment du type ou de l’espace de nom contenant)
  - Noms entièrement qualifiés dans le [format d’identification](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)de documentation du symbole . Chaque nom de symbole nécessite un préfixe de type symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de nom, etc.
  - `.ctor`pour les `.cctor` constructeurs et pour les constructeurs statiques

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés 'MyType' dans la compilation
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés 'MyType1' ou 'MyType2' dans la compilation
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique 'MyMethod' avec une signature entièrement qualifiée
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Correspond aux méthodes spécifiques 'MyMethod1' et 'MyMethod2' avec une signature entièrement qualifiée

Vous pouvez configurer toutes ces options pour cette règle, pour toutes les règles, ou pour toutes les règles de cette catégorie (Conception). Pour plus d’informations, voir [Configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Règles connexes

- [CA2213 : Les champs pouvant être supprimés doivent l'être](../code-quality/ca2213.md)
- [CA2202 : Ne pas supprimer des objets plusieurs fois](../code-quality/ca2202.md)

## <a name="example"></a>Exemple

Si vous implémentez une méthode qui renvoie un objet jetable, utilisez un bloc d’essai/enfin sans bloc de capture pour vous assurer que l’objet est éliminé. En utilisant un bloc d’essai/enfin, vous autorisez des exceptions à être soulevées au point de défaut et assurez-vous que l’objet est éliminé.

Dans la méthode OpenPort1, l’appel à ouvrir l’objet ISerializable SerialPort ou l’appel à SomeMethod peut échouer. Un avertissement CA2000 est soulevé sur cette mise en œuvre.

Dans la méthode OpenPort2, deux objets SerialPort sont déclarés et mis à l’annulation :

- `tempPort`, qui est utilisé pour tester que les opérations de méthode réussissent.

- `port`, qui est utilisé pour la valeur de retour de la méthode.

Le `tempPort` est construit et `try` ouvert dans un bloc, et `try` tout autre travail requis est effectué dans le même bloc. À la fin `try` du bloc, le port `port` ouvert est affecté `tempPort` à l’objet qui sera retourné et l’objet est réglé à `null`.

Le `finally` bloc vérifie `tempPort`la valeur de . Si elle n’est pas nulle, une `tempPort` opération de la méthode a échoué, et est fermée pour s’assurer que toutes les ressources sont libérées. L’objet bâbord retourné contiendra l’objet SerialPort ouvert si les opérations de la méthode ont réussi, ou il sera nul en cas d’échec d’une opération.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Exemple

Par défaut, le compilateur Visual Basic a tous les opérateurs arithmétiques vérifier le débordement. Par conséquent, toute opération arithmétique <xref:System.OverflowException>Visual Basic pourrait jeter un . Cela pourrait entraîner des violations imprévues dans des règles telles que CA2000. Par exemple, la fonction CreateReader1 suivante produira une violation du CA2000 parce que le compilateur visual basic émet une instruction de vérification des débordements pour l’ajout qui pourrait jeter une exception qui ferait que le StreamReader ne soit pas éliminé.

Pour résoudre ce problème, vous pouvez désactiver l’émission de contrôles de débordement par le compilateur Visual Basic dans votre projet ou vous pouvez modifier votre code comme dans la fonction CreateReader2 suivante.

Pour désactiver l’émission de contrôles de débordement, cliquez à droite sur le nom du projet dans Solution Explorer, puis cliquez sur **Propriétés**. Cliquez sur **Compile**, cliquez sur **Advanced Compile Options**, puis vérifiez **supprimer les contrôles de débordement integer**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Voir aussi

- <xref:System.IDisposable>
- [Dispose, modèle](/dotnet/standard/design-guidelines/dispose-pattern)
