---
title: 'CA1021 : Éviter les paramètres out'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 579b04f26af972ac025b0bfc07bc8dc9eb636d12
ms.sourcegitcommit: 98421670ed0b8170aaa32d3d6f8681298f401a1d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/18/2020
ms.locfileid: "81638030"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021 : Éviter les paramètres out

|||
|-|-|
|TypeName|AvoidOutParameters|
|CheckId|CA1021|
|Category|Microsoft.Design (en)|
|Modification avec rupture|Rupture|

## <a name="cause"></a>Cause
Une méthode publique ou protégée de `out` type public comporte un paramètre.

Par défaut, cette règle ne regarde que les types visibles à l’extérieur, mais [c’est configurable](#configurability).

## <a name="rule-description"></a>Description de la règle
Passer les types `out` par `ref`référence (à l’aide ou) nécessite de l’expérience avec les pointeurs, comprendre comment les types de valeur et les types de référence diffèrent, et les méthodes de manipulation avec des valeurs de retour multiples. En outre, `out` la `ref` différence entre et les paramètres n’est pas largement comprise.

Lorsqu’un type de référence est adopté « par référence », la méthode a l’intention d’utiliser le paramètre pour renvoyer une autre instance de l’objet. Passer un type de référence par référence est également connu comme utilisant un double pointeur, pointeur à un pointeur, ou double indirection. En utilisant la convention d’appel par défaut, qui est passer «par valeur», un paramètre qui prend un type de référence reçoit déjà un pointeur à l’objet. Le pointeur, et non l’objet auquel il pointe, est passé par valeur. Passer par valeur signifie que la méthode ne peut pas modifier le pointeur pour qu’il indique une nouvelle instance du type de référence. Cependant, il peut modifier le contenu de l’objet auquel il pointe. Pour la plupart des applications, cela est suffisant et donne le comportement souhaité.

Si une méthode doit renvoyer une instance différente, utilisez la valeur de retour de la méthode pour y parvenir. Consultez <xref:System.String?displayProperty=fullName> la classe pour une variété de méthodes qui fonctionnent sur les cordes et de retourner une nouvelle instance d’une chaîne. Lorsque ce modèle est utilisé, l’appelant doit décider si l’objet d’origine est conservé.

Bien que les valeurs de retour soient `out` `ref` courantes et fortement utilisées, l’application correcte et les paramètres exigent des compétences intermédiaires de conception et de codage. Les architectes de bibliothèque qui conçoivent pour `out` un `ref` public général ne doivent pas s’attendre à ce que les utilisateurs maîtrisent le travail avec ou les paramètres.

## <a name="how-to-fix-violations"></a>Comment corriger les violations
Pour corriger une violation de cette règle qui est causée par un type de valeur, demandez à la méthode de retourner l’objet comme valeur de retour. Si la méthode doit retourner plusieurs valeurs, redessinez-la pour retourner une seule instance d’un objet qui détient les valeurs.

Pour corriger une violation de cette règle qui est causée par un type de référence, assurez-vous que le comportement souhaité est de retourner une nouvelle instance de la référence. Si c’est le cas, la méthode devrait utiliser sa valeur de retour pour ce faire.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements
Il est sûr de supprimer un avertissement de cette règle. Cependant, cette conception pourrait causer des problèmes d’utilisabilité.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir [d’analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), vous pouvez configurer les parties de votre base de code pour exécuter cette règle, en fonction de leur accessibilité. Par exemple, pour spécifier que la règle ne doit s’exécuter que par rapport à la surface non publique de l’API, ajoutez la paire de valeur clé suivante à un fichier .editorconfig dans votre projet :

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

Vous pouvez configurer cette option pour cette règle, pour toutes les règles, ou pour toutes les règles de cette catégorie (Conception). Pour plus d’informations, voir [Configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Exemple
La bibliothèque suivante affiche deux implémentations d’une classe qui génère des réponses aux commentaires d’un utilisateur. La première`BadRefAndOut`implémentation ( ) oblige l’utilisateur de la bibliothèque à gérer trois valeurs de retour. La deuxième`RedesignedRefAndOut`implémentation ( ) simplifie l’expérience`ReplyData`utilisateur en retournant une instance d’une classe de conteneurs () qui gère les données en tant qu’unité unique.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>Exemple
L’application suivante illustre l’expérience de l’utilisateur. L’appel à la`UseTheSimplifiedClass` bibliothèque redessinée (méthode) est plus simple, et l’information retournée par la méthode est facilement gérée. La sortie des deux méthodes est identique.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>Exemple
L’exemple suivant de `ref` la bibliothèque illustre comment les paramètres des types de référence sont utilisés et montre une meilleure façon de mettre en œuvre cette fonctionnalité.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>Exemple
L’application suivante appelle chaque méthode dans la bibliothèque pour démontrer le comportement.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

Cet exemple produit la sortie suivante :

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>Essayez les méthodes de modèle

### <a name="description"></a>Description
Méthodes qui mettent en œuvre le <xref:System.Int32.TryParse%2A?displayProperty=fullName> **modèle Try\<Something>,** comme , ne soulèvent pas cette violation. L’exemple suivant montre une structure (type <xref:System.Int32.TryParse%2A?displayProperty=fullName> de valeur) qui implémente la méthode.

### <a name="code"></a>Code
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>Règles connexes
[CA1045 : Ne pas passer de types par référence](../code-quality/ca1045.md)
