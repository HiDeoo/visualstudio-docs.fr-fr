---
title: 'CA5389 : Ne pas ajouter le chemin de l’élément d’archive au chemin du système de fichiers cible'
description: Fournit des informations sur la règle d’analyse du code CA5389, notamment les causes, comment corriger les violations et quand la supprimer.
ms.date: 08/14/2019
ms.topic: reference
author: filipsebesta
ms.author: filipse
manager: jillfra
dev_langs:
- CSharp
ms.workload:
- multiple
f1_keywords:
- CA5389
- DoNotAddArchiveItemPathToTheTargetFileSystemPath
ms.openlocfilehash: 7b3a10697aafe39b8fdf453782c5dea40800df85
ms.sourcegitcommit: b885f26e015d03eafe7c885040644a52bb071fae
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/30/2020
ms.locfileid: "85521808"
---
# <a name="ca5389-do-not-add-archive-items-path-to-the-target-file-system-path"></a>CA5389 : Ne pas ajouter le chemin de l’élément d’archive au chemin du système de fichiers cible

|Élément|Valeur|
|-|-|
|CheckId|CA5389|
|Category|Microsoft.Security|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Le chemin d’accès au fichier source non nettoyé est utilisé comme chemin d’accès du fichier cible dans l’un des paramètres suivants :
- paramètre `destinationFileName` de la méthode<xref:System.IO.Compression.ZipFileExtensions.ExtractToFile%2A?displayProperty=nameWithType>
- chemin de paramètre de la méthode<xref:System.IO.File.Open%2A?displayProperty=nameWithType>
- chemin de paramètre de la méthode<xref:System.IO.File.OpenWrite%2A?displayProperty=nameWithType>
- chemin de paramètre de la méthode<xref:System.IO.File.Create%2A?displayProperty=nameWithType>
- chemin du paramètre du constructeur<xref:System.IO.FileStream?displayProperty=nameWithType>
- chemin du `fileName` paramètre<xref:System.IO.FileInfo?displayProperty=nameWithType>

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

## <a name="rule-description"></a>Description de la règle

Le chemin d’accès de fichier peut être relatif et peut entraîner l’accès au système de fichiers en dehors du chemin d’accès cible du système de fichiers attendu, ce qui conduit à des modifications de configuration malveillantes et à l’exécution de code à distance par le biais d’une technique de mise en attente.

## <a name="how-to-fix-violations"></a>Comment corriger les violations

N’utilisez pas le chemin d’accès au fichier source pour construire le chemin d’accès du fichier cible, ou vérifiez que le dernier caractère du chemin d’extraction est le caractère de séparation de répertoire.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Vous pouvez supprimer cet avertissement si le chemin source provient toujours d’une source approuvée.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir d' [analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), cette règle est configurable.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType` , ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA5389.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
  - `.ctor`pour les constructeurs et `.cctor` les constructeurs statiques

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA5389.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA5389.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA5389.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA5389.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (sécurité). Pour plus d’informations, consultez [configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Exemples de pseudo-code

### <a name="violation"></a>Violation

Au moment de l’écriture de cet article, l’exemple de pseudo-code suivant illustre le schéma détecté par cette règle.

```csharp
using System.IO.Compression;

class TestClass
{
    public void TestMethod(ZipArchiveEntry zipArchiveEntry)
    {
        zipArchiveEntry.ExtractToFile(zipArchiveEntry.FullName);
    }
}
```

### <a name="solution"></a>Solution

```csharp
using System;
using System.IO;
using System.IO.Compression;

class Program
{
    static void Main(string[] args)
    {
        string zipPath = @".\result.zip";

        Console.WriteLine("Provide path where to extract the zip file:");
        string extractPath = Console.ReadLine();

        // Normalizes the path.
        extractPath = Path.GetFullPath(extractPath);

        // Ensures that the last character on the extraction path
        // is the directory separator char.
        // Without this, a malicious zip file could try to traverse outside of the expected
        // extraction path.
        if (!extractPath.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
            extractPath += Path.DirectorySeparatorChar;

        using (ZipArchive archive = ZipFile.OpenRead(zipPath))
        {
            foreach (ZipArchiveEntry entry in archive.Entries)
            {
                if (entry.FullName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    // Gets the full path to ensure that relative segments are removed.
                    string destinationPath = Path.GetFullPath(Path.Combine(extractPath, entry.FullName));

                    // Ordinal match is safest, case-sensitive volumes can be mounted within volumes that
                    // are case-insensitive.
                    if (destinationPath.StartsWith(extractPath, StringComparison.Ordinal))
                        entry.ExtractToFile(destinationPath);
                }
            }
        }
    }
}
```
