---
title: 'CA5378 : Ne pas désactiver ServicePointManagerSecurityProtocols'
description: Fournit des informations sur la règle d’analyse du code CA5378, notamment les causes, comment corriger les violations et quand la supprimer.
ms.date: 07/12/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
f1_keywords:
- CA5378
- DoNotSetSwitch
ms.openlocfilehash: 10b3b12682b84045048727498769e147219a0770
ms.sourcegitcommit: d20ce855461c240ac5eee0fcfe373f166b4a04a9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/29/2020
ms.locfileid: "84183884"
---
# <a name="ca5378-do-not-disable-servicepointmanagersecurityprotocols"></a>CA5378 : Ne pas désactiver ServicePointManagerSecurityProtocols

|||
|-|-|
|CheckId|CA5378|
|Category|Microsoft.Security|
|Modification avec rupture|Sans rupture|

## <a name="cause"></a>Cause

Un <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> appel de méthode affecte `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` à la valeur `true` .

Par défaut, cette règle analyse l’ensemble du code base, mais il peut être [configuré](#configurability).

## <a name="rule-description"></a>Description de la règle

Le paramètre `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` pour `true` limite les connexions TLS (Transport Layer Security) de Windows Communication Framework (WCF) à l’utilisation de TLS 1,0. Cette version de TLS sera dépréciée. Pour plus d’informations, consultez [meilleures pratiques en matière de sécurité TLS (Transport Layer Security) avec l' .NET Framework](/dotnet/framework/network-programming/tls#switchsystemservicemodeldisableusingservicepointmanagersecurityprotocols).

## <a name="how-to-fix-violations"></a>Comment corriger les violations

- Si votre application cible .NET Framework v 4.7 ou une version ultérieure, vous pouvez soit supprimer l' <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> appel de méthode, soit définir la valeur du commutateur sur `false` .
- Si votre application cible .NET Framework v 4.6.2 ou une version antérieure et s’exécute sur .NET Framework v 4.7 ou version ultérieure, définissez la valeur du commutateur sur `false` .
- Dans le cas contraire, reportez-vous aux [meilleures pratiques de TLS (Transport Layer Security) avec le .NET Framework pour les](/dotnet/framework/network-programming/tls) atténuations.

## <a name="when-to-suppress-warnings"></a>Quand supprimer les avertissements

Vous pouvez supprimer cet avertissement si vous devez vous connecter à un service hérité qui ne peut pas être mis à niveau pour utiliser des configurations TLS sécurisées.

## <a name="configurability"></a>Configurabilité

Si vous exécutez cette règle à partir d' [analyseurs FxCop](install-fxcop-analyzers.md) (et non avec l’analyse héritée), cette règle est configurable.

### <a name="excluded-symbol-names"></a>Noms de symboles exclus

Vous pouvez configurer les parties de votre code base à exclure de l’analyse. Par exemple, pour spécifier que la règle ne doit pas être exécutée sur un code dans des types nommés `MyType` , ajoutez la paire clé-valeur suivante à un fichier. editorconfig dans votre projet :

```ini
dotnet_code_quality.CA5378.excluded_symbol_names = MyType
```

Formats de noms de symboles autorisés dans la valeur de l’option (séparés par' | ') :
  - Nom de symbole uniquement (comprend tous les symboles portant le nom, quel que soit le type ou l’espace de noms conteneur)
  - Noms qualifiés complets dans le format d' [ID de documentation](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)du symbole. Chaque nom de symbole requiert un préfixe de type de symbole, tel que le préfixe « M : » pour les méthodes, le préfixe « T : » pour les types, le préfixe « N : » pour les espaces de noms, etc.
  - `.ctor`pour les constructeurs et `.cctor` les constructeurs statiques

Exemples :

| Valeur d’option | Résumé |
| --- | --- |
|`dotnet_code_quality.CA5378.excluded_symbol_names = MyType` | Correspond à tous les symboles nommés’MyType’dans la compilation
|`dotnet_code_quality.CA5378.excluded_symbol_names = MyType1|MyType2` | Correspond à tous les symboles nommés’MyType1 'ou’MyType2 'dans la compilation
|`dotnet_code_quality.CA5378.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Correspond à la méthode spécifique’MyMethod’avec la signature complète donnée
|`dotnet_code_quality.CA5378.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Met en correspondance des méthodes spécifiques « MyMethod1 » et « MyMethod2 » avec la signature complète respective

Vous pouvez configurer toutes ces options uniquement pour cette règle, pour toutes les règles ou pour toutes les règles de cette catégorie (sécurité). Pour plus d’informations, consultez [configurer les analyseurs FxCop](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Exemples de pseudo-code

### <a name="violation"></a>Violation

```csharp
using System;

public class ExampleClass
{
    public void ExampleMethod()
    {
        // CA5378 violation
        AppContext.SetSwitch("Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols", true);
    }
}
```

```vb
Imports System

Public Class ExampleClass
    Public Sub ExampleMethod()
        ' CA5378 violation
        AppContext.SetSwitch("Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols", true)
    End Sub
End Class
```

### <a name="solution"></a>Solution

```csharp
using System;

public class ExampleClass
{
    public void ExampleMethod()
    {
        AppContext.SetSwitch("Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols", false);
    }
}
```

```vb
Imports System

Public Class ExampleClass
    Public Sub ExampleMethod()
        AppContext.SetSwitch("Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols", false)
    End Sub
End Class
```
