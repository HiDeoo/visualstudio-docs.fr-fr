---
title: Règles de performance par ID | Microsoft Docs
ms.custom: ''
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-ide-debug
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9a1c934c-4798-4df9-a8ef-eb17ef06b6a2
caps.latest.revision: 14
author: mikejo5000
ms.author: mikejo
manager: ghogen
ms.openlocfilehash: ec66e2f1b04533759272b5266289d6c554288cd3
ms.sourcegitcommit: 9ceaf69568d61023868ced59108ae4dd46f720ab
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/12/2018
ms.locfileid: "49300701"
---
# <a name="performance-rules-by-id"></a>Règles de performance par ID
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Warning|Description|  
|-------------|-----------------|  
|[DA0001 : Utilisez StringBuilder pour les concaténations](../profiling/da0001-use-stringbuilder-for-concatenations.md)|Les appels à System.String.Concat représentent une part importante des données de profilage. Envisagez l’utilisation de la classe <xref:System.Text.StringBuilder> pour construire des chaînes à partir de plusieurs segments.|  
|[DA0002 : VSPerfCorProf.dll manquant](../profiling/da0002-vsperfcorprof-dll-is-missing.md)|Le profileur n’a pas trouvé VSPerfCorProf.dll lors de l’exécution du profilage. Cet avertissement se produit quand les outils en ligne de commande pour la collecte de données du profileur sont utilisés sans l’outil VSPerfCLREnv.cmd pour initialiser les variables d’environnement nécessaires.|  
|[DA0003 : Nombreux échantillons de noyau](../profiling/da0003-many-kernel-samples.md)|Une proportion importante des échantillons de la pile des appels qui ont été collectés pour l’application s’exécutaient en mode noyau. Envisagez de profiler votre application avec une autre méthode de profilage.|  
|[DA0004 : Utilisation intensive du processeur](../profiling/da0004-high-processor-usage.md)|L’utilisation du processeur (UC) était très élevée dans les données de profilage qui ont été collectées à l’aide de la méthode d’instrumentation. Utilisez la méthode de profilage par échantillonnage lorsque vous profilez une application utilisant le processeur de manière intensive.|  
|[DA0005 : Collections GC2 fréquentes](../profiling/da0005-frequent-gc2-collections.md)|Un nombre élevé d’objets mémoire .NET est actuellement récupéré dans le cadre d’un garbage collection de génération 2.|  
|[DA0006 : Remplacez Equals() pour les types valeur](../profiling/da0006-override-equals-parens-for-value-types.md)|Les appels à la méthode Equals ou aux opérateurs d’égalité d’un type valeur public représentent une part importante des données de profilage. Implémentez une méthode plus efficace.|  
|[DA0007 : N’utilisez pas d’exceptions pour le flux de contrôle](../profiling/da0007-avoid-using-exceptions-for-control-flow.md)|Un taux élevé de gestionnaires d’exceptions .NET Framework ont été appelés dans les données de profilage. Utilisez une autre logique de flux de contrôle pour réduire le nombre d’exceptions levées.|  
|[DA0008 : Peu d’échantillons collectés](../profiling/da0008-few-samples-collected.md)|Seuls quelques échantillons ont été collectés pendant l’exécution du profilage. Augmentez la durée d’exécution ou utilisez un taux d’échantillonnage plus rapide pour des résultats plus significatifs.|  
|[DA0009 : Pourcentage élevé de temps en JIT](http://msdn.microsoft.com/en-us/b60c1767-515c-41d9-81c2-c70d0b7024fd)|Un pourcentage important du temps d’exécution de l’application a été passé dans le compilateur JIT.|  
|[DA0010 : GetHashCode coûteux](../profiling/da0010-expensive-gethashcode.md)|Les appels à la méthode GetHashCode du type représentent une part importante des données de profilage, ou la méthode alloue de la mémoire.|  
|[DA0011 : CompareTo coûteux](../profiling/da0011-expensive-compareto.md)|La méthode CompareTo du type est coûteuse ou alloue de la mémoire.|  
|[DA0012 : Quantité importante de réflexion](../profiling/da0012-significant-amount-of-reflection.md)|Les appels aux méthodes System.Reflection, telles que InvokeMember et GetMember, ou aux méthodes de type telles que MemberInvoke, représentent une part importante des données de profilage. Quand vous pouvez, envisagez de remplacer ces méthodes par une liaison anticipée aux méthodes des assemblys dépendants.|  
|[DA0013 : Utilisation intensive de String.Split ou de String.Substring](../profiling/da0013-high-usage-of-string-split-or-string-substring.md)|Les appels aux méthodes System.String.Split ou System.String.Substring représentent une part importante des données de profilage. Utilisez System.String.IndexOf ou System.String.IndexOfAny si vous testez l’existence d’une sous-chaîne dans une chaîne.|  
|[DA0014 : Taux très élevés de pagination de la mémoire active sur le disque](../profiling/da0014-extremely-high-rates-of-paging-active-memory-to-disk.md)|Les données de performances système qui ont été collectées durant l’exécution du profilage indiquent qu’un taux très élevé de pagination de la mémoire active vers et depuis le disque a été relevé pendant toute la durée de l’exécution du profilage. De tels taux de pagination affectent généralement les performances et la réactivité de l’application. Réduisez les allocations de mémoire en modifiant les algorithmes. Envisagez également de revoir les besoins en mémoire de votre application. Réexécutez le profilage sur un ordinateur disposant de plus de mémoire.|  
|[DA0017 : Taux élevés de pagination de la mémoire active sur le disque](../profiling/da0017-high-rates-of-paging-active-memory-to-disk.md)|Les données de performances système qui ont été collectées durant l’exécution du profilage indiquent qu’un taux élevé de pagination de la mémoire active vers et depuis le disque a été relevé pendant toute la durée de l’exécution du profilage. De tels taux de pagination affectent généralement les performances et la réactivité de l’application. Réduisez les allocations de mémoire en modifiant les algorithmes. Envisagez également de revoir les besoins en mémoire de votre application. Réexécutez le profilage sur un ordinateur disposant de plus de mémoire.|  
|[DA0018 : Application 32 bits s’exécutant aux limites de la mémoire managée du processus](../profiling/da0018-32-bit-application-running-at-process-managed-memory-limits.md)|Les données système qui ont été collectées pendant le profilage indiquent que les tas de mémoire .NET Framework approchent de la taille maximale autorisée pour les tas managés dans un processus 32 bits. La valeur indiquée correspond à la valeur maximale des tas qui a été observée pendant que le processus profilé était actif. Envisagez d’optimiser l’utilisation des ressources gérées par l’application.|  
|[DA0021 : Taux élevé de garbage collection Gen 1](../profiling/da0021-high-rate-of-gen-1-garbage-collections.md)|Les données relatives aux performances système qui ont été collectées pendant le profilage indiquent qu’une importante quantité de mémoire allouée aux objets .NET Framework a été récupérée dans la génération 1 du garbage collection, par rapport à la collecte de données de la génération 0.|  
|[DA0022 : taux élevé de garbage collection Gen 2](../profiling/da0022-high-rate-of-gen-2-garbage-collections.md)|Les données relatives aux performances système qui ont été collectées pendant le profilage indiquent qu’une importante quantité de mémoire allouée aux objets .NET Framework a été récupérée dans la génération 2 du garbage collection, par rapport aux garbage collections de génération 0 et 1.|  
|[DA0023 : temps processeur GC élevé](../profiling/da0023-high-gc-cpu-time.md)|Les données relatives aux performances système qui ont été collectées pendant le profilage indiquent que le temps consacré à la garbage collection est très important, par rapport au temps total de traitement de l’application.|  
|[DA0024 : Temps UC GC excessif](../profiling/da0024-excessive-gc-cpu-time.md)|Les données relatives aux performances système qui sont collectées pendant le profilage indiquent que le temps consacré au garbage collection est extrêmement important, par rapport au temps total de traitement de l’application.|  
|[DA0026 : Traitement du temps UC excessif pour le noyau](../profiling/da0026-excessive-kernel-cpu-time-processing.md)|Le temps processeur qui a été exécuté en mode noyau a dépassé le temps passé en mode utilisateur. Effectuez de nouveau un profilage et un échantillonnage du nombre d’appels système (syscalls) pour déterminer la cause des durées élevées d’exécution en mode noyau.|  
|[DA0029 : Version CLR non prise en charge](../profiling/da0029-unsupported-clr-version.md)|Vous essayez de profiler une application qui utilise le .NET Framework version 1.1, qui n’est pas pris en charge par les outils de profilage.|  
|[DA0030 : collecter les mesures d’interaction de couche pour les projets de base de données](../profiling/da0030-gather-tier-interaction-measurements-for-database-projects.md)|Les appels aux méthodes <xref:System.Data> représentent une part importante des données de profilage et vous n’avez pas collecté de données d’interaction de couche lors de l’exécution du profilage. Effectuez un nouveau profilage et ajoutez des données d’interaction de couche.|  
|[DA0038 : taux élevé de conflits de verrouillage](../profiling/da0038-high-rate-of-lock-contentions.md)|Les données relatives aux performances système qui sont collectées avec les données de profilage indiquent qu’un taux très élevé de conflits de verrouillage a été relevé lors de l’exécution de l’application. Effectuez un nouveau profilage à l’aide de la méthode de profilage d’accès concurrentiel pour rechercher la cause des conflits.|  
|[DA0039 : Taux très élevé de conflits de verrouillage](../profiling/da0039-very-high-rate-of-lock-contentions.md)|Les données relatives aux performances système qui sont collectées avec les données de profilage indiquent qu’un taux excessif de conflits de verrouillage a été relevé lors de l’exécution de l’application. Effectuez un nouveau profilage à l’aide de la méthode de profilage d’accès concurrentiel pour rechercher la cause des conflits.|  
|[DA0501 : Consommation d’UC moyenne par le processus en cours de profilage.](../profiling/da0501-average-cpu-consumption-by-the-process-being-profiled.md)|Ce message indique le temps, en pourcentage, pendant lequel un processeur a exécuté des instructions à partir de l’application. La valeur signalée correspond à la moyenne de tous les intervalles de mesure pendant lesquels le processus profilé était actif. Cette valeur peut être supérieure à 100 % sur les ordinateurs qui comprennent plusieurs processeurs.|  
|[DA0502 : consommation d’UC maximale par le processus à profiler](../profiling/da0502-maximum-cpu-consumption-by-the-process-being-profiled.md)|Ce message indique le temps maximal, en pourcentage, pendant lequel un processeur a exécuté des instructions à partir de l’application. La valeur signalée correspond à la valeur maximale de tous les intervalles de mesure pendant lesquels le processus profilé était actif. Cette valeur peut être supérieure à 100 % sur les ordinateurs qui comprennent plusieurs processeurs.|  
|[DA0503 : Jeu de travail moyen, en octets, pour le processus à profiler](../profiling/da0503-average-working-set-in-bytes-for-the-process-being-profiled.md)|Ce message signale la quantité moyenne de mémoire physique que le processus utilise actuellement, en octets (le jeu de travail). Le jeu de travail du processus comprend les pages de l’espace d’adressage de processus qui résident actuellement dans la mémoire physique.|  
|[DA0504 : Jeu de travail maximal, en octets, pour le processus à profiler](../profiling/da0504-maximum-working-set-in-bytes-for-the-process-being-profiled.md)|Ce message indique la quantité maximale de mémoire physique, en octets, utilisée par le processus. Le jeu de travail du processus comprend les pages de l’espace d’adressage de processus qui résident actuellement dans la mémoire physique. Cette règle signale la valeur maximale du jeu de travail du processus pendant que le profilage était actif.|  
|[DA0505 : Nombre moyen d’octets privés alloués pour le processus à profiler](../profiling/da0505-average-private-bytes-allocated-for-the-process-being-profiled.md)|Ce message signale la quantité moyenne de mémoire virtuelle actuellement allouée par le processus, en octets (octets privés). Les octets privés représentent les emplacements de mémoire virtuelle alloués par le processus et qui ne sont accessibles qu’aux threads actuellement exécutés dans le processus.|  
|[DA0506 : nombre maximal d’octets privés alloués pour le processus en cours de profilage](../profiling/da0506-maximum-private-bytes-allocated-for-the-process-being-profiled.md)|Ce message signale la quantité maximale de mémoire virtuelle actuellement allouée par le processus, en octets (octets privés). Les octets privés représentent les emplacements de mémoire virtuelle alloués par le processus et qui ne sont accessibles qu’aux threads actuellement exécutés dans le processus.|



