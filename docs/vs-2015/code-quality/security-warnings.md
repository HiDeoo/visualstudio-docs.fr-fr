---
title: Avertissements de sécurité | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
caps.latest.revision: 30
author: gewarren
ms.author: gewarren
manager: wpickett
ms.openlocfilehash: 37347946f01a752fa6e656c61754fa2702a1f517
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "68142114"
---
# <a name="security-warnings"></a>Avertissements liés à la sécurité
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Les avertissements de sécurité prennent en charge des bibliothèques et des applications plus sûres. Ces avertissements contribuent à empêcher la présence de défauts de sécurité dans votre programme. Si vous désactivez chacun de ces avertissements, vous devez indiquer clairement le motif de l’opération dans le code et également en informer le responsable de la sécurité désigné pour votre projet de développement.  
  
## <a name="in-this-section"></a>Dans cette section  
  
|Règle|Description|  
|----------|-----------------|  
|[CA2100 : Passez en revue les requêtes SQL pour les failles de sécurité](../code-quality/ca2100-review-sql-queries-for-security-vulnerabilities.md)|Une méthode définit la propriété System.Data.IDbCommand.CommandText à l’aide d’une chaîne générée à partir d’un argument de chaîne à la méthode. Cette règle suppose que l’argument de chaîne contient des entrées d’utilisateur. Une chaîne de commande SQL construite à partir d’entrées d’utilisateur est vulnérable aux attaques d’injection SQL.|  
|[CA2102 : Interceptez les exceptions non CLSCompliant dans les gestionnaires généraux](../code-quality/ca2102-catch-non-clscompliant-exceptions-in-general-handlers.md)|Un membre dans un assembly qui n’est pas marqué avec RuntimeCompatibilityAttribute ou qui est marqué avec RuntimeCompatibility(WrapNonExceptionThrows = false) contient un bloc catch qui gère System.Exception et ne contient pas de bloc catch général immédiatement après.|  
|[CA2103 : Vérifiez la sécurité impérative](../code-quality/ca2103-review-imperative-security.md)|Une méthode utilise la sécurité impérative et est susceptible de construire l’autorisation à l’aide d’informations d’état ou de valeurs de retour qui peuvent changer pendant que la demande est active. Utilisez la sécurité de déclaration dès que possible.|  
|[CA2104 : Ne déclarez pas les types référence mutables uniquement en lecture](../code-quality/ca2104-do-not-declare-read-only-mutable-reference-types.md)|Un type visible de l’extérieur contient un champ en lecture seule visible de l’extérieur qui constitue un type référence mutable. Un type mutable est un type dont les données d’instance peuvent être modifiées.|  
|[CA2105 : Champs de tableau ne doivent pas être en lecture seule](../code-quality/ca2105-array-fields-should-not-be-read-only.md)|Lorsque vous appliquez le modificateur en lecture seule (ReadOnly en Visual Basic) à un champ qui contient un tableau, ce champ ne peut pas être modifié pour référencer un tableau différent. Toutefois, les éléments du tableau stockés dans un champ en lecture seule peuvent être modifiés.|  
|[CA2106 : Assertions sécurisées](../code-quality/ca2106-secure-asserts.md)|Une méthode déclare une autorisation et aucune vérification de sécurité n’est exécutée sur l’appelant. L’assertion d’une autorisation de sécurité effectuée sans vérification de sécurité peut rendre votre code vulnérable et facile à exploiter.|  
|[CA2107 : Révision refuser et autoriser uniquement l’utilisation](../code-quality/ca2107-review-deny-and-permit-only-usage.md)|La méthode PermitOnly et les actions de sécurité CodeAccessPermission.Deny doivent être uniquement utilisées par les développeurs ayant des connaissances approfondies de la sécurité du .NET Framework. Le code qui utilise ces actions de sécurité doit subir une révision de sécurité.|  
|[CA2108 : Vérifiez la sécurité déclarative dans les types valeur](../code-quality/ca2108-review-declarative-security-on-value-types.md)|Un type valeur public ou protégé est sécurisé par l’accès aux données ou des demandes de liaison.|  
|[CA2109 : Passez en revue les gestionnaires d’événements visibles](../code-quality/ca2109-review-visible-event-handlers.md)|Une méthode de gestion d’événements publique ou protégée a été détectée. Les méthodes de gestion d’événements ne doivent pas être exposées sauf nécessité absolue.|  
|[CA2111 : Les pointeurs ne doivent pas être visibles](../code-quality/ca2111-pointers-should-not-be-visible.md)|Un pointeur n’est ni privé, ni interne ni en lecture seule. Un code malveillant peut modifier la valeur du pointeur, autorisant potentiellement l’accès aux emplacements arbitraires en mémoire ou provoquant des défaillances des applications ou du système.|  
|[CA2112 : Types sécurisés ne doivent pas exposer de champs](../code-quality/ca2112-secured-types-should-not-expose-fields.md)|Un type public ou protégé contient des champs publics et est sécurisé par des demandes de liaison. Si un code a accès à une instance d’un type sécurisé par une demande de liaison, ce code n’a pas besoin de satisfaire la demande de liaison pour accéder aux champs du type.|  
|[CA2114 : Sécurité de la méthode doit être un sur-ensemble du type](../code-quality/ca2114-method-security-should-be-a-superset-of-type.md)|Pour une même action, une méthode ne doit pas présenter de sécurité déclarative à la fois au niveau méthode et au niveau type.|  
|[CA2115 : Appelez GC. KeepAlive lors de l’utilisation des ressources natives](../code-quality/ca2115-call-gc-keepalive-when-using-native-resources.md)|Cette règle détecte les erreurs susceptibles de se produire du fait qu’une ressource non managée est en cours de finalisation alors qu’elle est encore utilisée dans un code non managé.|  
|[CA2116 : Les méthodes APTCA doivent uniquement appeler des méthodes APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale, et lorsque cet assembly exécute un code dans un autre assembly qui n’autorise pas les appelants dotés d’une confiance partielle, il devient possible d’exploiter une faille dans la sécurité.|  
|[CA2117 : Les types APTCA doivent uniquement étendre des types de base APTCA](../code-quality/ca2117-aptca-types-should-only-extend-aptca-base-types.md)|Lorsque l’attribut APTCA (AllowPartiallyTrustedCallers) est présent sur un assembly doté d’une confiance totale et lorsqu’un type présent dans l’assembly hérite d’un type qui n’autorise pas les appelants partiellement approuvés, une exploitation de la sécurité devient possible.|  
|[CA2118 : Passez en revue l’utilisation de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118-review-suppressunmanagedcodesecurityattribute-usage.md)|SuppressUnmanagedCodeSecurityAttribute modifie le comportement par défaut du système en matière de sécurité pour les membres qui exécutent le code non managé utilisant COM Interop ou l’appel de code non managé. Cet attribut est essentiellement utilisé pour accroître les performances ; toutefois, les gains de performance s’accompagnent de risques substantiels pour la sécurité.|  
|[CA2119 : Scellez les méthodes qui satisfont les interfaces privées](../code-quality/ca2119-seal-methods-that-satisfy-private-interfaces.md)|Un type public pouvant être hérité fournit une implémentation de méthode substituable d’une interface interne (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez la méthode d’être substituée en dehors de l’assembly.|  
|[CA2120 : Constructeurs de sérialisation sécurisé](../code-quality/ca2120-secure-serialization-constructors.md)|Ce type possède un constructeur qui accepte un objet System.Runtime.Serialization.SerializationInfo et un objet System.Runtime.Serialization.StreamingContext (la signature du constructeur de sérialisation). Ce constructeur n’est pas sécurisé par une vérification de la sécurité, mais au moins un des constructeurs normaux dans le type est sécurisé.|  
|[CA2121 : Les constructeurs statiques doivent être privés](../code-quality/ca2121-static-constructors-should-be-private.md)|Le système appelle le constructeur statique avant la création de la première instance du type ou le référencement de tout membre statique. Si un constructeur statique n’est pas privé, il peut être appelé par un code autre que le système. Selon les opérations effectuées dans le constructeur, cette possibilité peut provoquer un comportement inattendu.|  
|[CA2122 : N’exposez pas indirectement des méthodes avec des demandes de liaison](../code-quality/ca2122-do-not-indirectly-expose-methods-with-link-demands.md)|Un membre public ou protégé a des demandes de liaison et est appelé par un membre qui ne procède à aucune vérification de la sécurité. Une demande de liaison vérifie uniquement les autorisations de l’appelant immédiat.|  
|[CA2123 : Demandes de liaison de remplacement doivent être identiques de base](../code-quality/ca2123-override-link-demands-should-be-identical-to-base.md)|Cette règle met en correspondance une méthode et sa méthode de base, qui est soit une interface, soit une méthode virtuelle dans un autre type, puis compare les demandes de liaison sur chacune. Si cette règle est violée, un appelant malveillant peut ignorer la demande de liaison simplement en appelant la méthode non protégée.|  
|[CA2124 : Wrapper finally vulnérables clauses dans externe try](../code-quality/ca2124-wrap-vulnerable-finally-clauses-in-outer-try.md)|Une méthode publique ou protégée contient un bloc try/finally. Le bloc finally semble réinitialiser l’état de sécurité et n’est lui-même placé dans aucun bloc finally.|  
|[CA2126 : Demandes de liaison de type nécessitent des demandes d’héritage](../code-quality/ca2126-type-link-demands-require-inheritance-demands.md)|Un type unsealed public est protégé par une demande de liaison et a une méthode substituable. Ni le type ni la méthode n’est protégé par une demande d’héritage.|  
|[CA2136 : Membres ne doivent pas avoir des annotations de transparence conflictuelles](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Le code critique ne peut pas apparaître dans un assembly entièrement transparent. Cette règle analyse les assemblys entièrement transparents pour toutes les annotations SecurityCritical au niveau du type, du champ et de la méthode.|  
|[CA2147 : Les méthodes transparentes ne peuvent pas utiliser de sécurité des assertions](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est entièrement transparent ou mi-transparent et mi-critique, et elle signale toutes les utilisations déclaratives ou impératives d’Assert.|  
|[CA2140 : Le code transparent ne doit pas faire référence à des éléments critiques de sécurité](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Les méthodes marquées avec SecurityTransparentAttribute appellent des membres non publics marqués en tant que SecurityCritical. Cette règle analyse toutes les méthodes et tous les types dans un assembly qui est mi-transparent et mi-critique, et elle signale tous les appels du code transparent au code critique non public qui ne sont pas marqués comme SecurityTreatAsSafe.|  
  
|[CA2130 : Les constantes critiques de sécurité doivent être transparentes](../code-quality/ca2130-security-critical-constants-should-be-transparent.md)|La mise en application de la transparence n’est pas effectuée pour les valeurs de constante car les compilateurs alignent les valeurs de constante afin qu’aucune recherche ne soit requise au moment de l’exécution. Les champs constants doivent être transparents de sécurité (security-transparent) afin que les relecteurs de code ne supposent pas que le code transparent ne peut pas accéder à la constante.|  
|-----------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|[CA2131 : Types critiques de sécurité ne peuvent pas participer l’équivalence des types](../code-quality/ca2131-security-critical-types-may-not-participate-in-type-equivalence.md)|Un type participe à l’équivalence des types et un type lui-même, ou un membre ou champ du type, est marqué à l’aide de l’attribut SecurityCriticalAttribute. Cette règle se déclenche sur tout type ou type critique contenant des méthodes critiques ou des champs qui participent à l’équivalence de type. Lorsque le CLR détecte un tel type, il ne peut pas le charger avec une exception TypeLoadException au moment de l’exécution. En général, cette règle se déclenche uniquement lorsque les utilisateurs implémentent l’équivalence de type manuellement plutôt qu’en comptant sur tlbimp et les compilateurs pour faire l’équivalence de type.|  
|[CA2132 : Les constructeurs par défaut doivent être au moins aussi critiques que les constructeurs par défaut de type de base](../code-quality/ca2132-default-constructors-must-be-at-least-as-critical-as-base-type-default-constructors.md)|Les types et les membres qui possèdent l’attribut SecurityCriticalAttribute ne peuvent pas être utilisés par le code d’application Silverlight. Les types et membres critiques de sécurité (security-critical) peuvent être uniquement utilisés par le code de confiance dans la bibliothèque de classes .NET Framework pour Silverlight. Dans la mesure où une construction publique ou protégée dans une classe dérivée doit avoir la même transparence ou une transparence supérieure à sa classe de base, une classe dans une application ne peut pas être dérivée d’une classe marquée SecurityCritical.|  
|[CA2133 : Les délégués doivent lier aux méthodes avec une transparence cohérente](../code-quality/ca2133-delegates-must-bind-to-methods-with-consistent-transparency.md)|Cet avertissement se déclenche sur une méthode qui lie un délégué marqué à l’aide de SecurityCriticalAttribute à une méthode transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. L’avertissement déclenche également une méthode qui lie un délégué transparent ou critique sécurisé à une méthode critique.|  
|[CA2134 : Méthodes doit rester une transparence cohérente lors de la substitution des méthodes de base](../code-quality/ca2134-methods-must-keep-consistent-transparency-when-overriding-base-methods.md)|Cette règle se déclenche lorsqu’une méthode marquée à l’aide de SecurityCriticalAttribute substitue une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute. Cette règle se déclenche également lorsqu’une méthode qui est transparente ou marquée à l’aide de SecuritySafeCriticalAttribute substitue une méthode marquée à l’aide de SecurityCriticalAttribute. La règle est appliquée lors de la substitution d’une méthode virtuelle ou de l’implémentation d’une interface.|  
|[CA2135 : Assemblys de niveau 2 ne doivent pas contenir de LinkDemands](../code-quality/ca2135-level-2-assemblies-should-not-contain-linkdemands.md)|L’utilisation de LinkDemands est déconseillée dans l’ensemble de règles de sécurité de niveau 2. Au lieu d’utiliser LinkDemands pour implémenter la sécurité au moment de la compilation juste-à-temps (JIT), marquez les méthodes, types et champs avec l’attribut SecurityCriticalAttribute.|  
|[CA2136 : Membres ne doivent pas avoir des annotations de transparence conflictuelles](../code-quality/ca2136-members-should-not-have-conflicting-transparency-annotations.md)|Les attributs de transparence sont appliqués à partir d’éléments de code de plus grande portée à des éléments de plus petite portée. Les attributs de transparence d’éléments de code avec une plus grande portée sont prioritaires sur les attributs de transparence des éléments de code contenus dans le premier élément. Par exemple, une classe marquée à l’aide de l’attribut SecurityCriticalAttribute ne peut pas contenir de méthode marquée à l’aide de l’attribut SecuritySafeCriticalAttribute.|  
|[CA2137 : Les méthodes transparentes doivent contenir uniquement des IL vérifiables](../code-quality/ca2137-transparent-methods-must-contain-only-verifiable-il.md)|Une méthode contient du code non vérifiable ou retourne un type par référence. Cette règle se déclenche lorsque le code transparent de sécurité tente d’exécuter du code MSIL (Microsoft Intermediate Language) non vérifiable. Toutefois, la règle ne contient pas de vérificateur IL (Intermediate Language) complet, et à la place utilise l’heuristique pour intercepter la plupart des violations de vérification MSIL.|  
|[CA2138 : Les méthodes transparentes ne doivent pas appeler de méthodes avec l’attribut SuppressUnmanagedCodeSecurity](../code-quality/ca2138-transparent-methods-must-not-call-methods-with-the-suppressunmanagedcodesecurity-attribute.md)|Une méthode transparente de sécurité appelle une méthode qui est marquée à l’aide de l’attribut SuppressUnmanagedCodeSecurityAttribute.|  
|[CA2139 : Méthodes transparentes ne peuvent pas utiliser l’attribut HandleProcessCorruptingExceptions](../code-quality/ca2139-transparent-methods-may-not-use-the-handleprocesscorruptingexceptions-attribute.md)|Cette règle déclenche toute méthode transparente qui essaie de gérer une exception qui endommage un processus à l’aide de l’attribut HandleProcessCorruptedStateExceptionsAttribute. Une exception qui endommage un processus est une classification d’exception CLR version 4.0 des exceptions comme AccessViolationException. L’attribut HandleProcessCorruptedStateExceptionsAttribute peut uniquement être utilisé par des méthodes critiques de sécurité et sera ignoré s’il s’applique à une méthode transparente.|  
|[CA2140 : Le code transparent ne doit pas faire référence à des éléments critiques de sécurité](../code-quality/ca2140-transparent-code-must-not-reference-security-critical-items.md)|Un élément de code marqué à l’aide de l’attribut SecurityCriticalAttribute est critique de sécurité. Une méthode transparente ne peut pas utiliser un élément critique de sécurité. Si un type transparent essaie d’utiliser un type critique de sécurité, TypeAccessException, MethodAccessException ou FieldAccessException est déclenché.|  
|[CA2141 : Les méthodes transparentes ne satisfont pas les LinkDemands](../code-quality/ca2141-transparent-methods-must-not-satisfy-linkdemands.md)|Une méthode transparente de sécurité appelle une méthode dans un assembly qui n’est pas marqué à l’aide de l’attribut APTCA (AllowPartiallyTrustedCallersAttribute), ou une méthode transparente de sécurité satisfait une demande LinkDemand pour un type ou une méthode.|  
|[CA2142 : Le code transparent ne doit pas être protégé avec des LinkDemands](../code-quality/ca2142-transparent-code-should-not-be-protected-with-linkdemands.md)|Cette règle se déclenche sur les méthodes transparentes qui requièrent l’accès de LinkDemands. Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations.|  
|[CA2143 : Les méthodes transparentes ne doivent pas utiliser de demandes de sécurité](../code-quality/ca2143-transparent-methods-should-not-use-security-demands.md)|Le code transparent de sécurité ne doit pas être responsable de la vérification de la sécurité d’une opération. Par conséquent, il ne doit pas demander d’autorisations. Le code transparent de sécurité doit utiliser des demandes complètes pour prendre des décisions de sécurité et le code critique sécurisé ne doit pas dépendre du code transparent pour l’exécution de ces demandes.|  
|[CA2144 : Le code transparent ne doit pas charger les assemblys à partir de tableaux d’octets](../code-quality/ca2144-transparent-code-should-not-load-assemblies-from-byte-arrays.md)|La révision de sécurité du code transparent n’est pas aussi complète que la révision de sécurité du code critique, car le code transparent ne peut pas exécuter d’actions relatives à la sécurité. Les assemblys chargés à partir d’un tableau d’octets peuvent ne pas être remarqués dans du code transparent, et ce tableau d’octets peut contenir du code critique, voire critique de sécurité, qui doit être audité.|  
|[CA2145 : Méthodes transparentes ne doivent pas être décorées avec SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145-transparent-methods-should-not-be-decorated-with-the-suppressunmanagedcodesecurityattribute.md)|Les méthodes décorées avec l’attribut SuppressUnmanagedCodeSecurityAttribute ont un LinkDemand implicite sur toute méthode qui l’appelle. Ce LinkDemand requiert que le code appelant soit critique de sécurité. Le marquage de la méthode qui utilise SuppressUnmanagedCodeSecurity avec l’attribut SecurityCriticalAttribute rend cette spécification plus évidente pour les appelants de la méthode.|  
|[CA2146 : Types doivent être au moins aussi critiques que leurs types de base et les interfaces](../code-quality/ca2146-types-must-be-at-least-as-critical-as-their-base-types-and-interfaces.md)|Cette règle se déclenche lorsqu’un type dérivé a un attribut de transparence de sécurité qui n’est pas aussi critique que son type de base ou l’interface implémentée. Seuls les types critiques peuvent dériver des types de base critiques ou implémenter des interfaces critiques, et seuls les types critiques ou critiques sécurisés peuvent dériver des types de base critiques sécurisés ou implémenter des interfaces critiques sécurisées.|  
|[CA2147 : Les méthodes transparentes ne peuvent pas utiliser de sécurité des assertions](../code-quality/ca2147-transparent-methods-may-not-use-security-asserts.md)|Aucune autorisation suffisante n’est accordée à un code marqué comme attribut SecurityTransparentAttribute pour procéder à une assertion.|  
|[CA2149 : Méthodes transparentes ne doivent pas appeler du code natif](../code-quality/ca2149-transparent-methods-must-not-call-into-native-code.md)|Cette règle se déclenche sur toute méthode transparente qui appelle directement en code natif (par exemple, via un appel P/Invoke). Les violations de cette règle provoquent une exception MethodAccessException dans le modèle de transparence de niveau 2, et une demande complète pour le code UnmanagedCode dans le modèle de transparence de niveau 1.|  
|[CA2151 : Champs avec les types critiques doivent être critique de sécurité](../code-quality/ca2151-fields-with-critical-types-should-be-security-critical.md)|Pour utiliser les types critiques de sécurité, le code qui référence le type doit être critique de sécurité ou critique sécurisé. Ceci est vrai même si la référence est indirecte. Par conséquent, un champ transparent de sécurité ou critique sécurisé est trompeur, car le code transparent ne pourra toujours pas accéder au champ.|  
|[CA5122 : Les déclarations P-Invoke ne doivent pas être critiques sécurisées](../code-quality/ca5122-p-invoke-declarations-should-not-be-safe-critical.md)|Les méthodes sont marquées SecuritySafeCritical lorsqu’elles effectuent une opération relative à la sécurité, mais elle peuvent également être utilisées en toute sécurité par du code transparent. Le code transparent peut ne jamais appeler directement du code natif via P/Invoke. Par conséquent, marquer une méthode P/Invoke comme critique sécurisé ne permet pas au code transparent de l’appeler et s’avère trompeur pour l’analyse de sécurité.|  
|[CA2153 : Éviter la gestion des Exceptions d’état endommagé](../code-quality/ca2153-avoid-handling-corrupted-state-exceptions.md)|Les[exceptions d’état endommagé (CSE, Corrupted State Exceptions)](https://msdn.microsoft.com/magazine/dd419661.aspx) indiquent une altération de la mémoire dans votre processus. Le fait d’intercepter ces exceptions au lieu d’autoriser le processus à se bloquer peut engendrer des failles de sécurité si une personne malveillante réussit à placer une attaque dans la région de la mémoire endommagée.|  
|[CA3075 : Traitement DTD non sécurisé](../code-quality/ca3075-insecure-dtd-processing.md)|Si vous utilisez des instances de DTDProcessing non sécurisées ou référencez des sources d’entités externes, l’analyseur peut accepter une entrée non fiable et divulguer des informations sensibles à des personnes malveillantes.|  
|[CA3076 : Exécution du Script XSLT non sécurisé](../code-quality/ca3076-insecure-xslt-script-execution.md)|Si vous exécutez le langage XSLT (Extensible Stylesheet Language Transformations) dans les applications .NET de manière non sécurisée, le processeur peut résoudre les références URI non fiables qui pourraient divulguer des informations sensibles à des personnes malveillantes, ce qui aboutirait à des attaques par déni de service et intersites.|  
|[CA3077 : Traitement non sécurisé dans la conception d’API, Document XML et le lecteur de texte XML](../code-quality/ca3077-insecure-processing-in-api-design-xml-document-and-xml-text-reader.md)|Lors de la conception d’une API dérivée de XMLDocument et XMLTextReader, tenez compte de DtdProcessing.  L’utilisation d’instances de DTDProcessing non sécurisées lors de la référence ou la résolution de sources d’entités externes ou la définition de valeurs non sécurisées dans le code XML peut aboutir à la divulgation d’informations.|
