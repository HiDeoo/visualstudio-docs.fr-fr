---
title: C6298 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6298
helpviewer_keywords:
- C6298
ms.assetid: 986dc8e7-8596-4223-a66f-8616357d4399
caps.latest.revision: 15
author: mikeblome
ms.author: mblome
manager: jillfra
ms.openlocfilehash: 36587c60bee192f2d0d9463debdd137db21551af
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "68152458"
---
# <a name="c6298"></a>C6298
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

avertissement C6298 : utilisation d’une chaîne en lecture seule \<pointeur > comme un argument de chaîne accessible en écriture : cela tentera d’écrire dans la mémoire morte statique et provoquer des pannes aléatoires  
  
 Cet avertissement indique l’utilisation d’une chaîne constante en tant qu’argument à une fonction qui peut modifier le contenu de cette chaîne. Étant donné que le compilateur alloue des chaînes constantes dans une mémoire morte statique, toute tentative de modification provoque des violations d’accès et des pannes aléatoires.  
  
 Cela peut être évité en stockant la chaîne constante dans un tableau local, puis en utilisant le tableau comme argument à la fonction.  
  
## <a name="example"></a>Exemple  
 L’exemple de code suivant génère cet avertissement :  
  
```  
#include <windows.h>  
#include <stdio.h>  
  
void f()  
{  
    STARTUPINFO si;  
    PROCESS_INFORMATION pi;  
  
    ZeroMemory( &si, sizeof( si ) );  
    si.cb = sizeof( si );  
    ZeroMemory( &pi, sizeof( pi ) );  
    if( !CreateProcess(NULL,  
                      "\"c:\\Windows\\system32\\calc.exe\"",  
                      NULL,               
                      NULL,                
                      FALSE,              
                      0,                   
                      NULL,               
                      NULL,                
                      &si,                
                      &pi ) )   
    {  
        puts( "CreateProcess failed." );  
        return;  
    }  
  
    // Wait until child process exits.  
    WaitForSingleObject( pi.hProcess, INFINITE );  
  
    // Close process and thread handles.   
    CloseHandle( pi.hProcess );  
    CloseHandle( pi.hThread );  
}  
  
```  
  
 Pour corriger cet avertissement, utilisez l’exemple de code suivant :  
  
```  
#include <windows.h>  
#include <stdio.h>  
  
void f( )  
{  
    STARTUPINFO si;  
    PROCESS_INFORMATION pi;  
  
    char szCmdLine[] = "\"c:\\Windows\\system32\\calc.exe\"";  
    ZeroMemory( &si, sizeof( si ) );  
    si.cb = sizeof( si );  
    ZeroMemory( &pi, sizeof( pi ) );  
  
    if( !CreateProcess(NULL,  
                      szCmdLine,  
                      NULL,               
                      NULL,                
                      FALSE,              
                      0,                   
                      NULL,               
                      NULL,                
                      &si,                
                      &pi ) )   
    {  
        puts( "CreateProcess failed." );  
        return;  
    }  
  
    // Wait until child process exits.  
    WaitForSingleObject( pi.hProcess, INFINITE );  
  
    // Close process and thread handles.   
    CloseHandle( pi.hProcess );  
    CloseHandle( pi.hThread );  
}  
```
