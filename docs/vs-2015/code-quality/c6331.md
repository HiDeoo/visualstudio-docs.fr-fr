---
title: C6331 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6331
helpviewer_keywords:
- C6331
ms.assetid: cb1ecc2c-29a5-4c57-acf2-0954a4c047b1
caps.latest.revision: 14
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 0c88e01c9c9496920506f4bf8d79d6f19ca26ec2
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/02/2020
ms.locfileid: "77272795"
---
# <a name="c6331"></a>C6331
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

AVERTISSEMENT C6331 : paramètre non valide : le passage de MEM_RELEASE et MEM_DECOMMIT conjointement à \<function> n’est pas autorisé. Cela provoque l’échec de cet appel  
  
 Ce message indique qu’un paramètre non valide est passé à VirtualFree ou VirtualFreeEx. VirtualFree et VirtualFreeEx rejettent les indicateurs (MEM_RELEASE &#124; MEM_DECOMMIT) en combinaison. Par conséquent, les valeurs MEM_DECOMMIT et MEM_RELEASE ne peuvent pas être utilisées ensemble dans le même appel.  
  
 Elle n’est pas requise pour la désvalidation et la mise en service pour se produire comme des étapes indépendantes. La libération de la mémoire validée entraînera également la validation des pages. En outre, assurez-vous que la valeur de retour de cette fonction n’est pas ignorée.  
  
## <a name="example"></a>Exemple  
 L’exemple de code suivant génère cet avertissement :  
  
```  
#include <windows.h>  
#define PAGELIMIT 80  
  
DWORD dwPages = 0;  // count of pages   
DWORD dwPageSize;   // page size   
  
VOID fd( VOID )  
{  
  LPVOID lpvBase;            // base address of the test memory  
  BOOL bSuccess;             
  SYSTEM_INFO sSysInfo;      // system information  
  
  GetSystemInfo( &sSysInfo );    
  dwPageSize = sSysInfo.dwPageSize;  
  
  // Reserve pages in the process's virtual address space  
  lpvBase = VirtualAlloc (  
                       NULL,                 // system selects address  
                       PAGELIMIT*dwPageSize, // size of allocation  
                       MEM_RESERVE,          
                       PAGE_NOACCESS );       
  if (lpvBase)  
  {  
    // code to access memory   
  }  
  else  
  {  
    return;  
  }  
  bSuccess = VirtualFree(lpvBase,              
                0,  
                MEM_DECOMMIT | MEM_RELEASE); // warning   
  // code...  
}  
```  
  
 Pour corriger cet avertissement, ne transmettez pas MEM_DECOMMIT valeur à l’appel VirtualFree comme indiqué dans le code suivant :  
  
```  
#include <windows.h>  
#define PAGELIMIT 80  
  
DWORD dwPages = 0;  // count of pages   
DWORD dwPageSize;   // page size   
  
VOID f( VOID )  
{  
  LPVOID lpvBase;            // base address of the test memory  
  BOOL bSuccess;             
  SYSTEM_INFO sSysInfo;      // system information  
  
  GetSystemInfo( &sSysInfo );    
  dwPageSize = sSysInfo.dwPageSize;  
  
  // Reserve pages in the process's virtual address space  
  lpvBase = VirtualAlloc (  
                       NULL,                 // system selects address  
                       PAGELIMIT*dwPageSize, // size of allocation  
                       MEM_RESERVE,          
                       PAGE_NOACCESS );       
  if (lpvBase)  
  {  
    // code to access memory   
  }  
  else  
  {  
    return;  
  }  
  bSuccess = VirtualFree(lpvBase, 0, MEM_RELEASE);   
  // code...  
}  
```  
  
 Notez que l’utilisation des API malloc et Free (et des API d’allocation de mémoire dynamiques associées) présente de nombreux pièges en termes de fuites de mémoire et d’exceptions. Pour éviter l’ensemble de ces types de fuites et de problèmes d’exception, utilisez les mécanismes fournis par la bibliothèque STL (C++ Standard Template Library). Il s’agit notamment des [shared_ptr](https://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](https://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a)et [Vector](https://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Pour plus d’informations, consultez [pointeurs intelligents](https://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) et [bibliothèque standard C++](https://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
## <a name="see-also"></a>Voir aussi  
 [VirtualAlloc, méthode](https://msdn.microsoft.com/library/4dff3646-a050-4bd9-ac31-fe307e8637ec)   
 [VirtualFree, méthode](https://msdn.microsoft.com/library/1a436e89-eb28-4d15-bcf1-a072f86dbd99)
